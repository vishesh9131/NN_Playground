<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vishesh Yadav YT</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #4A90E2;
            --secondary-color: #333;
            --accent-color: #F5A623;
            --background-color: #F7F9FC;
            --card-background: #FFFFFF;
            --border-color: #E0E0E0;
            --text-color: #333;
            --text-light-color: #777;
            --positive-color: #4CAF50;
            --negative-color: #F44336;
            --neutral-color: #BDBDBD;

            --font-family-main: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --border-radius-main: 8px;
            --shadow-main: 0 4px 12px rgba(0, 0, 0, 0.08);
            --shadow-light: 0 2px 6px rgba(0, 0, 0, 0.05);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family-main);
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
            padding: 15px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow-x: hidden;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            grid-template-rows: auto 1fr auto;
            gap: 20px;
            align-items: flex-start;
            min-height: 100vh;
        }

        .section {
            background-color: var(--card-background);
            border-radius: var(--border-radius-main);
            padding: 20px;
            box-shadow: var(--shadow-main);
            margin-bottom: 20px;
        }

        .section h3 {
            margin-bottom: 15px;
            color: var(--secondary-color);
            font-weight: 600;
            font-size: 1rem;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 8px;
        }

        .control-group {
            margin-bottom: 15px;
            gap: 8px;
        }

        .control-group label {
            display: block;
            font-weight: 500;
            margin-bottom: 6px;
            font-size: 0.85rem;
            color: var(--text-light-color);
        }

        .control-group select,
        .control-group input[type="range"],
        .control-group input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: calc(var(--border-radius-main) - 2px);
            font-family: var(--font-family-main);
            font-size: 0.85rem;
            background-color: #fff;
        }
        
        .control-group input[type="range"] {
            padding: 0;
        }

        button {
            padding: 8px 16px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: calc(var(--border-radius-main) - 2px);
            cursor: pointer;
            font-weight: 500;
            font-family: var(--font-family-main);
            transition: background-color 0.2s ease, transform 0.1s ease;
            font-size: 0.85rem;
        }

        button:hover {
            background-color: #3A7DCE;
        }

        button:active {
            transform: translateY(1px);
        }

        button.secondary-action {
            background-color: var(--neutral-color);
            color: var(--secondary-color);
        }
        button.secondary-action:hover {
            background-color: #A0A0A0;
        }

        button:disabled {
            background-color: #D0D0D0;
            color: #A0A0A0;
            cursor: not-allowed;
            transform: translateY(0);
        }

        canvas {
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-main);
            display: block;
            margin: 10px auto;
            background-color: white;
            box-shadow: var(--shadow-light);
        }

        .layer-config-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 12px;
        }

        .layer-config {
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background-color: #F9F9F9;
            border-radius: calc(var(--border-radius-main) - 4px);
            border: 1px solid #EEE;
        }
        .layer-config label {
            margin-bottom: 0;
            font-size: 0.8rem;
        }
        .layer-config span {
            font-size: 0.8rem;
            text-align: right;
            min-width: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            grid-column: 1 / -1;
            padding: 15px 0;
            border-bottom: 1px solid var(--border-color);
        }

        h1 {
            color: var(--secondary-color);
            margin-bottom: 5px;
            font-weight: 700;
            font-size: 1.8rem;
        }
        header p {
            font-size: 0.9rem;
            color: var(--text-light-color);
        }

        .middle-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-height: 0;
            position: relative;
        }

        .main-network-section {
            flex: 1;
            min-height: 600px;
            background-color: var(--card-background);
            border-radius: var(--border-radius-main);
            padding: 20px;
            box-shadow: var(--shadow-main);
            position: relative;
        }

        .corner-overlays {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 20px;
            z-index: 10;
            flex-wrap: wrap;
            width: calc(100% - 20px);
            height: calc(100% - 20px);
            pointer-events: none;
        }

        .corner-overlay {
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: var(--border-radius-main);
            padding: 15px;
            box-shadow: var(--shadow-main);
            border: 1px solid var(--border-color);
            backdrop-filter: blur(10px);
            min-width: 280px;
            cursor: move;
            user-select: none;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            pointer-events: auto;
        }

        #loss-plot-overlay {
            min-width: 450px;
            background-color: rgba(248, 250, 252, 0.98);
            border: 1px solid rgba(74, 144, 226, 0.3);
        }

        #loss-plot-overlay h4 {
            color: var(--primary-color);
            font-weight: 700;
            margin-bottom: 10px;
            text-align: center;
        }

        #loss-canvas {
            border: 2px solid var(--primary-color);
            border-radius: 6px;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            box-shadow: 0 4px 12px rgba(74, 144, 226, 0.15);
        }

        .corner-overlay:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }

        .corner-overlay.dragging {
            cursor: grabbing;
            transform: scale(1.02);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            z-index: 2000 !important;
            position: fixed !important;
        }

        .corner-overlay h4 {
            margin: 0 0 8px 0;
            color: var(--secondary-color);
            font-weight: 600;
            font-size: 0.85rem;
            cursor: move;
            padding: 5px 0;
            border-bottom: 1px solid rgba(74, 144, 226, 0.2);
        }

        .corner-overlay h4:hover {
            color: var(--primary-color);
        }

        .corner-overlay canvas {
            border: 1px solid var(--border-color);
            border-radius: calc(var(--border-radius-main) - 2px);
            display: block;
            background-color: white;
            box-shadow: var(--shadow-light);
        }

        .corner-overlay .stats-display {
            margin: 8px 0 0 0;
        }

        .corner-overlay .stat-item {
            padding: 4px;
            font-size: 0.7rem;
        }

        .corner-overlay .stat-item div:first-child {
            font-size: 0.65rem;
        }

        .corner-overlay .stat-item div:last-child {
            font-size: 0.75rem;
        }

        .corner-overlay .loss-controls {
            margin: 4px 0;
        }

        .corner-overlay .loss-btn {
            padding: 4px 8px;
            font-size: 0.7rem;
        }

        #zoom-level {
            font-size: 0.65rem;
        }

        .output-loss-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: 300px;
        }

        .output-section, .loss-section {
            min-height: 0;
        }

        .stats-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
            gap: 8px;
            margin: 10px 0;
        }

        .stat-item {
            text-align: center;
            padding: 8px 6px;
            background: #F9F9F9;
            border-radius: calc(var(--border-radius-main) - 4px);
            border: 1px solid #EEE;
            font-size: 0.75rem;
        }
        .stat-item div:first-child {
            font-weight: 500;
            color: var(--text-light-color);
            margin-bottom: 3px;
            font-size: 0.7rem;
            text-transform: uppercase;
        }
        .stat-item div:last-child {
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--primary-color);
        }

        .legend {
            display: flex;
            justify-content: space-around;
            margin: 10px 0;
            font-size: 0.75rem;
            padding: 8px;
            background-color: #F9F9F9;
            border-radius: calc(var(--border-radius-main) - 4px);
            border: 1px solid #EEE;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid rgba(0,0,0,0.1);
        }

        #layers-control-group button {
            padding: 6px 10px;
            min-width: 32px;
        }

        .slider-value {
            display: inline-block;
            margin-left: 8px;
            font-weight: 500;
            color: var(--primary-color);
            min-width: 25px;
        }

        /* Responsive adjustments */
        @media (max-width: 1400px) {
            .container {
                grid-template-columns: 280px 1fr 280px;
                gap: 15px;
            }
            
            #network-canvas {
                width: 600px;
                height: 400px;
            }
            
            .corner-overlays {
                top: 10px;
                right: 10px;
                gap: 15px;
            }
            
            .corner-overlay {
                min-width: 220px;
            }
            
            .corner-overlay canvas {
                width: 200px !important;
                height: auto !important;
            }
        }

        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            #network-canvas {
                width: 500px;
                height: 350px;
            }
            
            .corner-overlays {
                position: relative;
                top: 0;
                right: 0;
                justify-content: center;
                margin: 15px 0;
            }
            
            .corner-overlay {
                min-width: 240px;
            }
            
            .main-network-section {
                min-height: 450px;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .section {
                padding: 15px;
            }
            h1 {
                font-size: 1.5rem;
            }
            
            #network-canvas {
                width: 100%;
                max-width: 400px;
                height: 300px;
            }
            
            .corner-overlays {
                flex-direction: column;
                align-items: center;
            }
            
            .corner-overlay {
                min-width: 200px;
            }
            
            .visual-computation {
                grid-template-columns: 1fr;
            }
        }

        .computation-section {
            grid-column: 1 / -1;
            margin-top: 10px;
        }

        .computation-display {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .gradient-info {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .layer-gradients {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            line-height: 1.4;
        }

        .gradient-layer {
            margin-bottom: 12px;
            padding: 8px;
            background-color: white;
            border-radius: 4px;
            border-left: 3px solid var(--primary-color);
        }

        .gradient-layer h4 {
            margin: 0 0 5px 0;
            color: var(--primary-color);
            font-size: 0.8rem;
            font-weight: 600;
        }

        .gradient-values {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 5px;
            margin-top: 5px;
        }

        .gradient-value {
            background-color: #f1f3f4;
            padding: 3px 6px;
            border-radius: 3px;
            text-align: center;
            font-size: 0.7rem;
        }

        .gradient-value.positive {
            background-color: #e3f2fd;
            color: #1976d2;
        }

        .gradient-value.negative {
            background-color: #ffebee;
            color: #d32f2f;
        }

        .gradient-value.zero {
            background-color: #f5f5f5;
            color: #757575;
        }

        .visual-computation {
            display: grid;
            grid-template-columns: 1fr 1.5fr;
            gap: 20px;
            margin: 15px 0;
        }

        .backprop-visual, .math-visualization {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
        }

        .backprop-visual h4, .math-visualization h4 {
            margin: 0 0 10px 0;
            color: var(--primary-color);
            font-size: 0.9rem;
            font-weight: 600;
        }

        #gradient-canvas {
            width: 100%;
            max-width: 400px;
            height: 200px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            display: block;
            margin: 10px 0;
        }

        .gradient-controls {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .gradient-btn, .loss-btn {
            padding: 6px 12px;
            font-size: 0.75rem;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s ease;
        }

        .gradient-btn:hover, .loss-btn:hover {
            background-color: #D89A1A;
        }

        .gradient-btn:active, .loss-btn:active {
            background-color: #C5891A;
        }

        .math-container {
            min-height: 160px;
            max-height: 200px;
            overflow-y: auto;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            line-height: 1.4;
        }

        .math-step {
            margin-bottom: 8px;
            padding: 6px;
            background-color: #f1f3f4;
            border-left: 3px solid var(--primary-color);
            border-radius: 3px;
        }

        .math-step.highlight {
            background-color: #fff3cd;
            border-left-color: var(--accent-color);
            animation: highlightPulse 1s ease-in-out;
        }

        @keyframes highlightPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .loss-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            margin: 8px 0;
            flex-wrap: wrap;
        }

        #zoom-level {
            font-size: 0.75rem;
            color: var(--text-light-color);
            font-weight: 500;
            margin-left: 8px;
        }

        .gradient-flow-particle {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: radial-gradient(circle, #ff6b6b, #ee5a24);
            animation: gradientFlow 2s linear infinite;
        }

        @keyframes gradientFlow {
            0% { transform: scale(0) rotate(0deg); opacity: 0; }
            10% { transform: scale(1) rotate(0deg); opacity: 1; }
            90% { transform: scale(1) rotate(360deg); opacity: 1; }
            100% { transform: scale(0) rotate(360deg); opacity: 0; }
        }

        .math-visualization {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
        }

        .math-visualization h4 {
            margin: 0 0 10px 0;
            color: var(--primary-color);
            font-size: 0.9rem;
            font-weight: 600;
        }

        .math-controls {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .math-btn {
            padding: 6px 12px;
            font-size: 0.75rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.3);
        }

        .math-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .math-btn:active {
            transform: translateY(0);
        }

        .math-btn.playing {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        #math-canvas {
            width: 100%;
            max-width: 600px;
            height: 400px;
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            display: block;
            margin: 15px auto;
            box-shadow: 0 8px 25px rgba(74, 144, 226, 0.15);
        }

        .equation-container {
            margin: 15px 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .equation-step {
            background: linear-gradient(135deg, #ffffff 0%, #f0f4f8 100%);
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            transition: all 0.4s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .equation-step::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(74, 144, 226, 0.1), transparent);
            transition: left 0.6s ease;
        }

        .equation-step.active {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, #e6f3ff 0%, #cce7ff 100%);
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(74, 144, 226, 0.3);
        }

        .equation-step.active::before {
            left: 100%;
        }

        .equation-step:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .equation-title {
            font-weight: 700;
            font-size: 0.8rem;
            color: var(--primary-color);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .equation-content {
            font-family: 'Courier New', 'Monaco', monospace;
            font-size: 1.1rem;
            font-weight: 600;
            color: #2d3748;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 4px;
            border: 1px solid rgba(74, 144, 226, 0.2);
        }

        .math-values-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .value-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .value-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, rgba(255, 255, 255, 0.1) 0%, transparent 100%);
            pointer-events: none;
        }

        .value-box:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .value-box.updating {
            animation: valueUpdate 0.8s ease;
        }

        @keyframes valueUpdate {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%); }
            100% { transform: scale(1); }
        }

        .value-label {
            display: block;
            font-size: 0.7rem;
            font-weight: 500;
            opacity: 0.9;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .value-number {
            display: block;
            font-size: 1.1rem;
            font-weight: 700;
            font-family: 'Courier New', 'Monaco', monospace;
        }

        /* Mathematical notation enhancements */
        .math-symbol {
            font-size: 1.2em;
            color: var(--accent-color);
            font-weight: bold;
        }

        .math-operator {
            color: #e74c3c;
            font-weight: bold;
            margin: 0 2px;
        }

        .math-variable {
            color: var(--primary-color);
            font-style: italic;
            font-weight: bold;
        }

        .math-result {
            background-color: rgba(245, 166, 35, 0.1);
            border: 1px solid var(--accent-color);
            border-radius: 4px;
            padding: 2px 4px;
            font-weight: bold;
        }

        /* Visual computation flow animations */
        .computation-flow {
            position: relative;
        }

        .flow-arrow {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 12px solid var(--accent-color);
            animation: flowPulse 2s infinite;
        }

        @keyframes flowPulse {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        /* Matrix visualization styles */
        .matrix-visual {
            display: inline-block;
            border: 2px solid var(--primary-color);
            border-radius: 4px;
            padding: 8px;
            background-color: rgba(74, 144, 226, 0.05);
            margin: 0 4px;
        }

        .matrix-element {
            display: inline-block;
            width: 30px;
            height: 20px;
            text-align: center;
            border: 1px solid rgba(74, 144, 226, 0.3);
            margin: 1px;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            background-color: white;
        }

        .matrix-element.highlight {
            background-color: var(--accent-color);
            color: white;
            animation: matrixHighlight 1s ease;
        }

        @keyframes matrixHighlight {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }

        /* Derivative visualization */
        .derivative-visual {
            background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%);
            border: 2px solid #e17055;
            border-radius: 8px;
            padding: 10px;
            margin: 5px 0;
            font-family: 'Courier New', monospace;
            text-align: center;
            box-shadow: 0 3px 10px rgba(225, 112, 85, 0.3);
        }

        .chain-rule-visual {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 10px 0;
        }

        .chain-step {
            background-color: white;
            border: 2px solid var(--primary-color);
            border-radius: 20px;
            padding: 8px 12px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .chain-step.active {
            background-color: var(--accent-color);
            color: white;
            transform: scale(1.1);
        }

        .chain-arrow {
            font-size: 1.5em;
            color: var(--accent-color);
            font-weight: bold;
        }

        /* Responsive adjustments for math visualization */
        @media (max-width: 768px) {
            #math-canvas {
                width: 100%;
                height: 300px;
            }
            
            .equation-container {
                grid-template-columns: 1fr;
            }
            
            .math-values-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .math-controls {
                justify-content: center;
            }
        }

        /* Ultra-Interactive Math Computation Styles */
        .interaction-modes {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .mode-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, #ecf0f1 0%, #bdc3c7 100%);
            color: #2c3e50;
            border: 2px solid transparent;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 0.8rem;
        }

        .mode-btn:hover {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #4A90E2 0%, #357ABD 100%);
            color: white;
            border-color: #2c3e50;
            box-shadow: 0 3px 10px rgba(74, 144, 226, 0.4);
        }

        .interaction-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 8px 12px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            border-left: 4px solid var(--primary-color);
            font-size: 0.75rem;
            flex-wrap: wrap;
            gap: 8px;
        }

        .interaction-status span {
            color: #495057;
            font-weight: 500;
        }

        #current-mode {
            background-color: var(--primary-color);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-weight: 600;
        }

        /* Interactive Parameter Panel */
        .interactive-params {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 15px 0;
            padding: 15px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border-radius: 12px;
            border: 2px solid #e9ecef;
        }

        .param-section {
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            border: 1px solid #dee2e6;
        }

        .param-section h5 {
            margin: 0 0 10px 0;
            color: var(--primary-color);
            font-weight: 700;
            font-size: 0.9rem;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 5px;
        }

        .param-row {
            display: grid;
            grid-template-columns: auto 1fr 2fr;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .param-row label {
            font-weight: 600;
            color: #495057;
            font-size: 0.8rem;
            margin: 0;
        }

        .param-input {
            padding: 4px 8px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-weight: 600;
            background: white;
            transition: all 0.3s ease;
        }

        .param-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
            outline: none;
        }

        .param-slider {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: linear-gradient(90deg, #e9ecef 0%, var(--primary-color) 50%, #e9ecef 100%);
            border-radius: 3px;
            outline: none;
            transition: all 0.3s ease;
        }

        .param-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, var(--primary-color) 0%, #357ABD 100%);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(74, 144, 226, 0.3);
            transition: all 0.3s ease;
        }

        .param-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 3px 10px rgba(74, 144, 226, 0.5);
        }

        /* Weight Grid */
        .weight-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .weight-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .weight-item:hover {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, #e6f3ff 0%, #cce7ff 100%);
            transform: translateY(-2px);
        }

        .weight-input {
            width: 80px;
            padding: 4px;
            margin: 4px 0;
            text-align: center;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-weight: 700;
            background: white;
        }

        .weight-visual {
            width: 60px;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(90deg, #e74c3c 0%, #f1c40f 50%, #2ecc71 100%);
            position: relative;
            margin-top: 4px;
            cursor: pointer;
        }

        .weight-visual::after {
            content: '';
            position: absolute;
            top: -2px;
            left: 50%;
            width: 4px;
            height: 12px;
            background: #2c3e50;
            border-radius: 2px;
            transform: translateX(-50%);
            transition: all 0.3s ease;
        }

        /* Interactive Equations */
        .interactive-equations .equation-step {
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .interactive-equations .equation-step::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(74, 144, 226, 0.1), transparent);
            transition: left 0.6s ease;
        }

        .interactive-equations .equation-step:hover::before {
            left: 100%;
        }

        .interactive-formula {
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .math-term {
            padding: 2px 4px;
            border-radius: 4px;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .math-term:hover {
            background-color: rgba(74, 144, 226, 0.2);
            transform: scale(1.1);
            z-index: 10;
        }

        .math-term.clickable:hover {
            background-color: rgba(245, 166, 35, 0.3);
            color: #d68910;
            font-weight: 700;
        }

        /* Computation Graph */
        .computation-graph {
            margin: 15px 0;
            padding: 15px;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border-radius: 12px;
            border: 2px solid #e9ecef;
        }

        .computation-graph h5 {
            margin: 0 0 15px 0;
            color: var(--primary-color);
            font-weight: 700;
            text-align: center;
        }

        .graph-container {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            align-items: center;
            position: relative;
            min-height: 80px;
        }

        .graph-node {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            z-index: 2;
        }

        .graph-node.input-node {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .graph-node.hidden-node {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
        }

        .graph-node.output-node {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }

        .graph-node:hover {
            transform: scale(1.2);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        .node-label {
            font-weight: 700;
            font-size: 0.8rem;
        }

        .node-value {
            font-size: 0.7rem;
            font-family: 'Courier New', monospace;
            font-weight: 600;
        }

        .graph-edge {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 0.7rem;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1;
        }

        .graph-edge:hover {
            background: var(--primary-color);
            color: white;
            transform: scale(1.1);
            z-index: 5;
        }

        /* Interactive Value Boxes */
        .interactive-values .value-box {
            position: relative;
            overflow: visible;
        }

        .interactive-box {
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .interactive-box:hover {
            border-color: var(--primary-color);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(74, 144, 226, 0.2);
        }

        .edit-hint {
            font-size: 0.6rem;
            color: #999;
            font-style: italic;
        }

        .scrubable {
            cursor: ew-resize;
            user-select: none;
            position: relative;
        }

        .scrubable:hover {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            border-radius: 4px;
            padding: 2px 4px;
        }

        .computed {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            border-radius: 4px;
            padding: 2px 4px;
        }

        .value-controls {
            display: flex;
            gap: 4px;
            margin-top: 5px;
            justify-content: center;
        }

        .mini-btn {
            padding: 2px 6px;
            font-size: 0.7rem;
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mini-btn:hover {
            background: linear-gradient(135deg, var(--primary-color) 0%, #357ABD 100%);
            transform: scale(1.1);
        }

        /* Tutorial Overlay */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tutorial-overlay.hidden {
            display: none;
        }

        .tutorial-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .tutorial-content h5 {
            margin: 0 0 20px 0;
            color: var(--primary-color);
            font-size: 1.2rem;
            text-align: center;
        }

        .tutorial-step {
            text-align: center;
        }

        .step-content {
            margin-bottom: 20px;
            font-size: 1rem;
            line-height: 1.6;
        }

        .tutorial-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: white;
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            min-width: 150px;
        }

        .context-menu.hidden {
            display: none;
        }

        .menu-item {
            padding: 10px 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 1px solid #dee2e6;
            font-size: 0.9rem;
        }

        .menu-item:last-child {
            border-bottom: none;
        }

        .menu-item:hover {
            background: linear-gradient(135deg, var(--primary-color) 0%, #357ABD 100%);
            color: white;
        }

        /* Hover Tooltip */
        .hover-tooltip {
            position: fixed;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            z-index: 1500;
            pointer-events: none;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            max-width: 200px;
        }

        .hover-tooltip.hidden {
            display: none;
        }

        .tooltip-content {
            line-height: 1.4;
        }

        /* Interactive animations */
        @keyframes pulse-interact {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes glow-interact {
            0%, 100% { box-shadow: 0 0 5px rgba(74, 144, 226, 0.3); }
            50% { box-shadow: 0 0 20px rgba(74, 144, 226, 0.6); }
        }

        @keyframes wiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(1deg); }
            75% { transform: rotate(-1deg); }
        }

        .interactive-element:hover {
            animation: pulse-interact 1s infinite;
        }

        .clickable-element:hover {
            animation: glow-interact 1s infinite;
        }

        .draggable-element:active {
            animation: wiggle 0.3s ease;
        }

        /* Drag and drop feedback */
        .dragging {
            opacity: 0.8;
            transform: scale(1.05) rotate(2deg);
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .drop-target {
            border: 2px dashed var(--primary-color);
            background: rgba(74, 144, 226, 0.1);
        }

        .drop-valid {
            border-color: #2ecc71;
            background: rgba(46, 204, 113, 0.1);
        }

        .drop-invalid {
            border-color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
        }

        /* Keyboard shortcuts display */
        .keyboard-shortcut {
            position: absolute;
            top: -20px;
            right: 5px;
            font-size: 0.6rem;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 4px;
            border-radius: 3px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .interactive-element:hover .keyboard-shortcut {
            opacity: 1;
        }

        /* Multi-selection */
        .selected {
            border: 3px solid var(--accent-color) !important;
            background: rgba(245, 166, 35, 0.1) !important;
        }

        .multi-selected {
            border: 3px solid #e74c3c !important;
            background: rgba(231, 76, 60, 0.1) !important;
        }

        /* Loading states */
        .loading {
            opacity: 0.6;
            pointer-events: none;
            position: relative;
        }

        .loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            transform: translate(-50%, -50%);
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* Responsive adjustments for interactive elements */
        @media (max-width: 768px) {
            .interactive-params {
                grid-template-columns: 1fr;
            }
            
            .param-row {
                grid-template-columns: 1fr;
                gap: 4px;
            }
            
            .weight-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .graph-container {
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
            }
            
            .interaction-modes {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .tutorial-content {
                margin: 20px;
                padding: 20px;
            }
        }

        /* Beginner-Friendly Backpropagation Simulator Styles */
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Vishesh's Playground for Neural Network </h1>
            <p>A visual introduction to machine learning with animations</p>
        </header>

        <div class="section left-panel">
            <h3>Data</h3>
            <div class="control-group">
                <label>Problem Type:</label>
                <select id="problem-type">
                    <option value="classification">Classification</option>
                    <option value="regression">Regression</option>
                </select>
            </div>
            <div class="control-group">
                <label>Dataset:</label>
                <select id="dataset-select">
                </select>
            </div>
            <canvas id="data-canvas" width="250" height="220"></canvas>
            <p style="text-align: center; font-size: 11px; color: #666;">
                Click to add points (regression: drag to set value)
            </p>

            <h3>Hidden Layers</h3>
            <div class="control-group">
                <label>Layers:</label>
                <div id="layers-control-group" style="display: flex; align-items: center; gap: 8px;">
                    <button id="remove-layer" class="secondary-action">-</button>
                    <span id="layers-count" style="font-weight: 500; min-width: 20px; text-align: center;">1</span>
                    <button id="add-layer" class="secondary-action">+</button>
                </div>
            </div>
            <div id="layers-config-container" class="layer-config-container"></div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #3498db;"></div>
                    <span>Input</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #9b59b6;"></div>
                    <span>Hidden</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #e74c3c;"></div>
                    <span>Output</span>
                </div>
            </div>
        </div>

        <div class="middle-panel">
            <div class="main-network-section">
                <h3>Neural Network Architecture</h3>
                
                <!-- Corner overlays for decision boundary and loss -->
                <div class="corner-overlays">
                    <div id="decision-boundary-overlay" class="corner-overlay">
                        <h4>Decision Boundary <span style="font-size: 0.7em; color: #999;">(drag anywhere)</span></h4>
                        <canvas id="output-canvas" width="240" height="180"></canvas>
                    </div>
                    
                    <div id="loss-plot-overlay" class="corner-overlay">
                        <h4>Live Loss Plot <span style="font-size: 0.7em; color: #999;">(drag anywhere)</span></h4>
                        <div class="loss-controls">
                            <button id="zoom-in" class="loss-btn">🔍+</button>
                            <button id="zoom-out" class="loss-btn">🔍-</button>
                            <button id="zoom-reset" class="loss-btn">↻</button>
                            <button id="auto-scale" class="loss-btn">📈 Auto</button>
                            <span id="zoom-level">1x</span>
                        </div>
                        <canvas id="loss-canvas" width="400" height="280"></canvas>
                        <div class="stats-display">
                            <div class="stat-item">
                                <div>Current</div>
                                <div id="current-loss">-</div>
                            </div>
                            <div class="stat-item">
                                <div>Min</div>
                                <div id="min-loss">-</div>
                            </div>
                            <div class="stat-item">
                                <div>Range</div>
                                <div id="loss-range">-</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Large network visualization -->
                <canvas id="network-canvas" width="800" height="500"></canvas>
                
                <div class="stats-display">
                    <div class="stat-item">
                        <div>Training Status</div>
                        <div id="training-status">Ready</div>
                    </div>
                    <div class="stat-item">
                        <div>Weights</div>
                        <div>Live</div>
                    </div>
                    <div class="stat-item">
                        <div>Activations</div>
                        <div>Live</div>
                    </div>
                </div>
            </div>

            <div class="section computation-section">
                <h3>Backpropagation Computation</h3>
                <div class="computation-display">
                    <div class="gradient-info">
                        <div class="stat-item">
                            <div>Loss Gradient</div>
                            <div id="loss-gradient">-</div>
                        </div>
                        <div class="stat-item">
                            <div>Avg Weight Update</div>
                            <div id="weight-update">-</div>
                        </div>
                        <div class="stat-item">
                            <div>Gradient Norm</div>
                            <div id="gradient-norm">-</div>
                        </div>
                    </div>
                    
                    <div class="visual-computation">
                        <div class="backprop-visual">
                            <h4>Gradient Flow Visualization</h4>
                            <canvas id="gradient-canvas" width="400" height="200"></canvas>
                            <div class="gradient-controls">
                                <button id="play-gradient-flow" class="gradient-btn">▶ Play Gradient Flow</button>
                                <button id="step-gradient" class="gradient-btn">⏭ Step Through</button>
                                <button id="reset-gradient" class="gradient-btn">↻ Reset</button>
                            </div>
                        </div>
                        
                        <div class="math-visualization">
                            <h4>📹 Watch the Full Tutorial <span style="font-size: 0.7em; color: #999;">(Deep Learning Masterclass)</span></h4>
                            
                            <!-- YouTube Video Embed -->
                            <div class="video-container">
                                <div class="video-header">
                                    <h5>🎓 ML Masterclass from ex-Nvidia - Day 5</h5>
                                    <p>This Changed How I See Deep Learning! Watch the complete explanation behind this neural network playground.</p>
                                </div>
                                
                                <div class="video-wrapper">
                                    <iframe 
                                        src="https://www.youtube.com/embed/vppqoJ5wPjY?si=y_ZotqTumMvahVYV" 
                                        title="ML Masterclass from ex-Nvidia - Day 5" 
                                        frameborder="0" 
                                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
                                        allowfullscreen>
                                    </iframe>
                                </div>
                                
                                <div class="video-description">
                                    <div class="video-stats">
                                        <div class="stat-item">
                                            <span class="stat-label">Series:</span>
                                            <span class="stat-value">ML Masterclass</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">Episode:</span>
                                            <span class="stat-value">Day 5</span>
                                        </div>
                                        <div class="stat-item">
                                            <span class="stat-label">Topic:</span>
                                            <span class="stat-value">Neural Networks</span>
                                        </div>
                                    </div>
                                    
                                    <div class="video-cta">
                                        <p><strong>💡 Learn More:</strong> This playground was built as part of the ML Masterclass series. Watch the full explanation to understand how neural networks really work!</p>
                                        <a href="https://youtu.be/vppqoJ5wPjY?si=y_ZotqTumMvahVYV" target="_blank" class="video-link">
                                            🔗 Open in YouTube
                                        </a>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="layer-gradients" id="layer-gradients">
                        <p style="font-size: 0.8rem; color: #666; text-align: center;">Start training to see gradient computations...</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="section right-panel">
            <h3>Training</h3>
            <div class="control-group">
                <label for="learning-rate">Learning Rate:</label>
                <div style="display: flex; align-items: center;">
                    <input type="range" id="learning-rate" min="0.001" max="0.1" step="0.001" value="0.01">
                    <span id="lr-value" class="slider-value">0.01</span>
                </div>
            </div>
            <div class="control-group">
                <label for="activation-select">Activation:</label>
                <select id="activation-select">
                    <option value="relu">ReLU</option>
                    <option value="leakyRelu">Leaky ReLU (Better)</option>
                    <option value="tanh">Tanh</option>
                    <option value="sigmoid">Sigmoid</option>
                    <option value="elu">ELU</option>
                </select>
            </div>
            <div class="control-group">
                <label for="animation-speed">Training Speed:</label>
                <div style="display: flex; align-items: center;">
                    <input type="range" id="animation-speed" min="1" max="10" value="5">
                    <span id="speed-value" class="slider-value">5</span>
                </div>
            </div>
            <div class="control-group" style="display: flex; gap: 8px;">
                <button id="train-btn">Start Training</button>
                <button id="reset-btn" class="secondary-action">Reset</button>
            </div>
            <div class="stats-display">
                <div class="stat-item">
                    <div>Epoch</div>
                    <div id="epoch">0</div>
                </div>
                <div class="stat-item">
                    <div>Loss</div>
                    <div id="loss">-</div>
                </div>
                <div class="stat-item">
                    <div>Metric</div>
                    <div id="accuracy">-</div>
                </div>
                <div class="stat-item">
                    <div>Learning Rate</div>
                    <div id="current-lr">0.01</div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <script>
        // Global state
        let model = null;
        let trainingData = [];
        let hiddenLayers = [8];
        let isTraining = false;
        let epoch = 0;
        let lossHistory = [];
        let minLoss = Infinity;
        let maxLoss = -Infinity;
        let showWeights = true;
        let showActivations = true;
        let currentActivations = null;
        let currentWeights = null;
        let currentGradients = null;
        let animationSpeed = 5;
        let problemType = 'classification';

        // Zoom and interaction state
        let lossZoomLevel = 1;
        let lossViewStart = 0;
        let lossViewEnd = 100;
        let gradientAnimationStep = 0;
        let gradientAnimationRunning = false;
        let mathSteps = [];
        let autoScaleEnabled = true;
        let autoMagnifyEnabled = true;
        let recentLossWindow = 50; // Show last 50 epochs by default

        // Drag state for corner overlays
        let isDragging = false;
        let dragElement = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let overlayPositions = {
            decisionBoundary: { x: null, y: null },
            lossPlot: { x: null, y: null }
        };

        // Dataset definitions
        const datasets = {
            classification: {
                circle: 'Circle',
                xor: 'XOR',
                spiral: 'Spiral',
                gaussian: 'Gaussian Clusters'
            },
            regression: {
                linear: 'Linear',
                quadratic: 'Quadratic',
                sine: 'Sine Wave',
                cubic: 'Cubic'
            }
        };

        // Get DOM elements
        const dataCanvas = document.getElementById('data-canvas');
        const networkCanvas = document.getElementById('network-canvas');
        const outputCanvas = document.getElementById('output-canvas');
        const lossCanvas = document.getElementById('loss-canvas');
        const dataCtx = dataCanvas.getContext('2d');
        const networkCtx = networkCanvas.getContext('2d');
        const outputCtx = outputCanvas.getContext('2d');
        const lossCtx = lossCanvas.getContext('2d');

        // Control elements
        const problemTypeSelect = document.getElementById('problem-type');
        const datasetSelect = document.getElementById('dataset-select');
        const lrSlider = document.getElementById('learning-rate');
        const lrValue = document.getElementById('lr-value');
        const activationSelect = document.getElementById('activation-select');
        const trainBtn = document.getElementById('train-btn');
        const resetBtn = document.getElementById('reset-btn');
        const addLayerBtn = document.getElementById('add-layer');
        const removeLayerBtn = document.getElementById('remove-layer');
        const layersCountSpan = document.getElementById('layers-count');
        const layersConfigContainer = document.getElementById('layers-config-container');
        const epochSpan = document.getElementById('epoch');
        const lossSpan = document.getElementById('loss');
        const accuracySpan = document.getElementById('accuracy');
        const currentLrSpan = document.getElementById('current-lr');
        const currentLossSpan = document.getElementById('current-loss');
        const minLossSpan = document.getElementById('min-loss');
        const animationSpeedSlider = document.getElementById('animation-speed');
        const speedValueSpan = document.getElementById('speed-value');
        const trainingStatusSpan = document.getElementById('training-status');

        // Gradient computation elements
        const lossGradientSpan = document.getElementById('loss-gradient');
        const weightUpdateSpan = document.getElementById('weight-update');
        const gradientNormSpan = document.getElementById('gradient-norm');
        const layerGradientsDiv = document.getElementById('layer-gradients');
        const gradientCanvas = document.getElementById('gradient-canvas');
        const gradientCtx = gradientCanvas.getContext('2d');
        const mathDisplayDiv = document.getElementById('math-display');

        // Interactive controls
        const playGradientBtn = document.getElementById('play-gradient-flow');
        const stepGradientBtn = document.getElementById('step-gradient');
        const resetGradientBtn = document.getElementById('reset-gradient');
        const zoomInBtn = document.getElementById('zoom-in');
        const zoomOutBtn = document.getElementById('zoom-out');
        const zoomResetBtn = document.getElementById('zoom-reset');
        const autoScaleBtn = document.getElementById('auto-scale');
        const zoomLevelSpan = document.getElementById('zoom-level');
        const lossRangeSpan = document.getElementById('loss-range');

        // Initialize application
        async function init() {
            if (typeof tf === 'undefined') {
                alert('TensorFlow.js failed to load!');
                return;
            }

            console.log('Initializing Neural Network Playground...');

            // Initialize all global arrays properly
            trainingData = [];
            hiddenLayers = [8];
            lossHistory = [];
            currentActivations = null;
            currentWeights = null;

            // Set up event listeners
            problemTypeSelect.addEventListener('change', () => {
                problemType = problemTypeSelect.value;
                updateDatasetOptions();
                generateData();
                createModel();
            });

            datasetSelect.addEventListener('change', () => {
                generateData();
            });

            lrSlider.addEventListener('input', () => {
                lrValue.textContent = lrSlider.value;
                currentLrSpan.textContent = lrSlider.value;
                createModel();
            });

            animationSpeedSlider.addEventListener('input', () => {
                animationSpeed = parseInt(animationSpeedSlider.value);
                speedValueSpan.textContent = animationSpeed;
            });

            activationSelect.addEventListener('change', createModel);
            trainBtn.addEventListener('click', toggleTraining);
            resetBtn.addEventListener('click', resetModel);
            addLayerBtn.addEventListener('click', addLayer);
            removeLayerBtn.addEventListener('click', removeLayer);

            // Canvas events
            dataCanvas.addEventListener('click', addPoint);
            dataCanvas.addEventListener('contextmenu', addPoint);

            // Interactive controls for gradients and zoom
            playGradientBtn.addEventListener('click', playGradientFlow);
            stepGradientBtn.addEventListener('click', stepGradientFlow);
            resetGradientBtn.addEventListener('click', resetGradientFlow);
            zoomInBtn.addEventListener('click', () => zoomLoss(1.5));
            zoomOutBtn.addEventListener('click', () => zoomLoss(0.67));
            zoomResetBtn.addEventListener('click', resetLossZoom);
            autoScaleBtn.addEventListener('click', toggleAutoScale);

            // Initialize
            updateDatasetOptions();
            generateData();
            updateLayerConfig();
            createModel();
            drawNetwork();
            initializeLossPlot();
            initializeGradientCanvas();
            initializeDraggableOverlays();
            initializeMathVisualization(); // Initialize the new math visualization system

            console.log('Neural Network Playground initialized successfully!');
        }

        function updateDatasetOptions() {
            datasetSelect.innerHTML = '';
            const options = datasets[problemType];
            for (const [value, label] of Object.entries(options)) {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = label;
                datasetSelect.appendChild(option);
            }
        }

        function updateCurrentWeights() {
            if (!model || !model.layers) return;
            
            try {
                currentWeights = [];
                model.layers.forEach((layer, i) => {
                    if (layer && typeof layer.getWeights === 'function') {
                        const weights = layer.getWeights();
                        if (weights && weights.length > 0 && weights[0]) {
                            const weightData = Array.from(weights[0].dataSync());
                            currentWeights[i] = weightData;
                        } else {
                            currentWeights[i] = null;
                        }
                    }
                });
            } catch (error) {
                console.error('Error updating weights:', error);
                currentWeights = null;
            }
        }

        // Generate training data
        function generateData() {
            trainingData = []; 
            
            const type = datasetSelect.value;
            const n = 50;

            if (problemType === 'classification') {
                if (type === 'circle') {
                    for (let i = 0; i < n * 2; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * 110 + 10;
                        const x = 125 + Math.cos(angle) * radius;
                        const y = 125 + Math.sin(angle) * radius;
                        const label = radius < 60 ? 1 : 0;
                        if (x >= 0 && x < 250 && y >= 0 && y < 220) {
                            trainingData.push({ x, y, label });
                        }
                    }
                } else if (type === 'xor') {
                    for (let i = 0; i < n * 2; i++) {
                        const x = Math.random() * 240 + 5;
                        const y = Math.random() * 210 + 5;
                        const label = (x < 125 && y < 110) || (x >= 125 && y >= 110) ? 1 : 0;
                        trainingData.push({ x, y, label });
                    }
                } else if (type === 'spiral') {
                    for (let c = 0; c < 2; c++) {
                        for (let i = 0; i < n; i++) {
                            const t = i / n * 3 * Math.PI;
                            const r = t * 6;
                            const x = 125 + Math.cos(t + c * Math.PI) * r;
                            const y = 110 + Math.sin(t + c * Math.PI) * r;
                            if (x >= 0 && x < 250 && y >= 0 && y < 220) {
                                trainingData.push({ x, y, label: c });
                            }
                        }
                    }
                } else if (type === 'gaussian') {
                    for (let c = 0; c < 2; c++) {
                        const centerX = c === 0 ? 80 : 170;
                        const centerY = c === 0 ? 70 : 150;
                        for (let i = 0; i < n; i++) {
                            const x = centerX + (Math.random() - 0.5) * 80;
                            const y = centerY + (Math.random() - 0.5) * 60;
                            if (x >= 0 && x < 250 && y >= 0 && y < 220) {
                                trainingData.push({ x, y, label: c });
                            }
                        }
                    }
                }
            } else { // regression
                if (type === 'linear') {
                    for (let i = 0; i < n * 2; i++) {
                        const x = Math.random() * 240 + 5;
                        const noise = (Math.random() - 0.5) * 30;
                        const y = 40 + x * 0.6 + noise;
                        const clampedY = Math.max(5, Math.min(215, y));
                        const normalizedLabel = clampedY / 220;
                        trainingData.push({ x, y: clampedY, label: normalizedLabel });
                    }
                } else if (type === 'quadratic') {
                    for (let i = 0; i < n * 2; i++) {
                        const x = Math.random() * 240 + 5;
                        const noise = (Math.random() - 0.5) * 25;
                        const y = 180 - Math.pow((x - 125) / 50, 2) * 80 + noise;
                        const clampedY = Math.max(5, Math.min(215, y));
                        const normalizedLabel = clampedY / 220;
                        trainingData.push({ x, y: clampedY, label: normalizedLabel });
                    }
                } else if (type === 'sine') {
                    for (let i = 0; i < n * 2; i++) {
                        const x = Math.random() * 240 + 5;
                        const noise = (Math.random() - 0.5) * 15;
                        const y = 110 + Math.sin((x - 5) / 240 * Math.PI * 3) * 60 + noise;
                        const clampedY = Math.max(5, Math.min(215, y));
                        const normalizedLabel = clampedY / 220;
                        trainingData.push({ x, y: clampedY, label: normalizedLabel });
                    }
                } else if (type === 'cubic') {
                    for (let i = 0; i < n * 2; i++) {
                        const x = Math.random() * 240 + 5;
                        const noise = (Math.random() - 0.5) * 25;
                        const normalizedX = (x - 125) / 100;
                        const y = 110 + Math.pow(normalizedX, 3) * 60 + noise;
                        const clampedY = Math.max(5, Math.min(215, y));
                        const normalizedLabel = clampedY / 220;
                        trainingData.push({ x, y: clampedY, label: normalizedLabel });
                    }
                }
                
                // Filter out invalid data
                trainingData = trainingData.filter(p => !isNaN(p.label) && isFinite(p.label));
            }

            // Final validation
            trainingData = trainingData.filter(point => {
                return point && 
                       typeof point.x === 'number' && 
                       typeof point.y === 'number' && 
                       typeof point.label === 'number' &&
                       !isNaN(point.x) && !isNaN(point.y) && !isNaN(point.label) &&
                       isFinite(point.x) && isFinite(point.y) && isFinite(point.label);
            });

            console.log(`Generated ${trainingData.length} training points for ${problemType} ${type}`);
            drawData();
            if (model) drawOutput();
        }

        // Create model
        function createModel() {
            if (model) {
                model.dispose();
            }

            const lr = parseFloat(lrSlider.value);
            const activation = activationSelect.value;
            
            try {
                const modelLayers = [];
                
                // First hidden layer
                if (activation === 'leakyRelu') {
                    modelLayers.push(tf.layers.dense({
                        inputShape: [2],
                        units: hiddenLayers[0],
                        kernelInitializer: 'glorotNormal',
                        biasInitializer: 'zeros',
                        name: 'hidden_0'
                    }));
                    modelLayers.push(tf.layers.leakyReLU({alpha: 0.1}));
                } else if (activation === 'elu') {
                    modelLayers.push(tf.layers.dense({
                        inputShape: [2],
                        units: hiddenLayers[0],
                        kernelInitializer: 'glorotNormal',
                        biasInitializer: 'zeros',
                        name: 'hidden_0'
                    }));
                    modelLayers.push(tf.layers.elu());
                } else {
                    modelLayers.push(tf.layers.dense({
                        inputShape: [2],
                        units: hiddenLayers[0],
                        activation: activation,
                        kernelInitializer: 'glorotNormal',
                        biasInitializer: 'zeros',
                        name: 'hidden_0'
                    }));
                }

                // Additional hidden layers
                for (let i = 1; i < hiddenLayers.length; i++) {
                    if (activation === 'leakyRelu') {
                        modelLayers.push(tf.layers.dense({
                            units: hiddenLayers[i],
                            kernelInitializer: 'glorotNormal',
                            biasInitializer: 'zeros',
                            name: `hidden_${i}`
                        }));
                        modelLayers.push(tf.layers.leakyReLU({alpha: 0.1}));
                    } else if (activation === 'elu') {
                        modelLayers.push(tf.layers.dense({
                            units: hiddenLayers[i],
                            kernelInitializer: 'glorotNormal',
                            biasInitializer: 'zeros',
                            name: `hidden_${i}`
                        }));
                        modelLayers.push(tf.layers.elu());
                    } else {
                        modelLayers.push(tf.layers.dense({
                            units: hiddenLayers[i],
                            activation: activation,
                            kernelInitializer: 'glorotNormal',
                            biasInitializer: 'zeros',
                            name: `hidden_${i}`
                        }));
                    }
                }

                // Output layer
                if (problemType === 'classification') {
                    modelLayers.push(tf.layers.dense({
                        units: 1,
                        activation: 'sigmoid',
                        kernelInitializer: 'glorotNormal',
                        biasInitializer: 'zeros',
                        name: 'output'
                    }));
                } else {
                    modelLayers.push(tf.layers.dense({
                        units: 1,
                        activation: 'linear',
                        kernelInitializer: 'glorotNormal',
                        biasInitializer: 'zeros',
                        name: 'output'
                    }));
                }

                model = tf.sequential({ layers: modelLayers });
                
                if (problemType === 'classification') {
                    model.compile({
                        optimizer: tf.train.adam(lr),
                        loss: 'binaryCrossentropy',
                        metrics: ['accuracy']
                    });
                } else {
                    model.compile({
                        optimizer: tf.train.adam(lr),
                        loss: tf.losses.meanSquaredError,
                        metrics: [tf.metrics.meanAbsoluteError]
                    });
                }

                epoch = 0;
                lossHistory = [];
                minLoss = Infinity;
                maxLoss = -Infinity;
                epochSpan.textContent = '0';
                lossSpan.textContent = '-';
                accuracySpan.textContent = '-';
                currentLossSpan.textContent = '-';
                minLossSpan.textContent = '-';

                // Initialize weights and activations since they're always shown now
                updateCurrentWeights();
                if (trainingData.length > 0) {
                    try {
                        tf.tidy(() => {
                            const sampleInput = tf.tensor2d([[trainingData[0].x / 250, trainingData[0].y / 220]]);
                            let currentProcessingTensor = sampleInput;
                            let activations = [[trainingData[0].x / 250, trainingData[0].y / 220]];
                            for (let i = 0; i < model.layers.length; i++) {
                                currentProcessingTensor = model.layers[i].apply(currentProcessingTensor);
                                // Only record activations from dense layers, not activation layers
                                if (model.layers[i].name && model.layers[i].name.includes('hidden') || model.layers[i].name === 'output') {
                                    activations.push(Array.from(currentProcessingTensor.dataSync()));
                                }
                            }
                            currentActivations = activations;
                        });
                    } catch (activationError) {
                        console.error('Error initializing activations:', activationError);
                    }
                }

                drawNetwork(); 
                initializeLossPlot();
                if (trainingData.length > 0) drawOutput();
                
                console.log('Model created successfully with improved initialization');
                
            } catch (error) {
                console.error("Model creation error:", error);
            }
        }

        // Layer management
        function addLayer() {
            if (hiddenLayers.length < 4) {
                hiddenLayers.push(6);
                updateLayerConfig();
                createModel();
            }
        }

        function removeLayer() {
            if (hiddenLayers.length > 1) {
                hiddenLayers.pop();
                updateLayerConfig();
                createModel();
            }
        }

        function updateLayerConfig() {
            layersCountSpan.textContent = hiddenLayers.length;
            layersConfigContainer.innerHTML = '';

            hiddenLayers.forEach((neurons, i) => {
                const div = document.createElement('div');
                div.className = 'layer-config';

                const label = document.createElement('label');
                label.textContent = `Layer ${i + 1}:`;
                label.htmlFor = `layer-neurons-${i}`;

                const input = document.createElement('input');
                input.type = 'range';
                input.min = '2';
                input.max = '12';
                input.value = neurons;
                input.id = `layer-neurons-${i}`;

                const span = document.createElement('span');
                span.textContent = neurons;

                input.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    hiddenLayers[i] = value;
                    span.textContent = value;
                    if(model) {
                        createModel();
                    }
                });

                div.appendChild(label);
                div.appendChild(input);
                div.appendChild(span);
                layersConfigContainer.appendChild(div);
            });
        }

        // Add data point
        function addPoint(e) {
            e.preventDefault();
            
            const rect = dataCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (problemType === 'classification') {
                const label = e.type === 'contextmenu' ? 0 : 1;
                trainingData.push({ x, y, label });
            } else {
                const label = (y - 5) / 210;
                trainingData.push({ x, y, label });
            }

            drawData();
            if (model) drawOutput();
        }

        // Get network architecture info
        function getNetworkArchitecture() {
            if (!hiddenLayers || !Array.isArray(hiddenLayers) || hiddenLayers.length === 0) {
                hiddenLayers = [8];
            }
            
            const layers = [2, ...hiddenLayers, 1];
            const canvasWidth = networkCanvas.width;
            const canvasHeight = networkCanvas.height;
            const layerX = layers.map((_, i) => 80 + i * ((canvasWidth - 160) / (layers.length - 1)));
            
            const neurons = [];
            const connections = [];
            
            try {
                layers.forEach((layerSize, layerIdx) => {
                    const x = layerX[layerIdx];
                    const spacing = Math.min((canvasHeight - 160) / Math.max(layerSize, 1), 40);
                    const startY = canvasHeight/2 - (layerSize - 1) * spacing / 2;

                    const layerNeurons = [];
                    for (let i = 0; i < layerSize; i++) {
                        const y = startY + i * spacing;
                        layerNeurons.push({ x, y, layer: layerIdx, index: i });
                    }
                    neurons.push(layerNeurons);

                    if (layerIdx < layers.length - 1) {
                        const nextLayerSize = layers[layerIdx + 1];
                        const nextSpacing = Math.min((canvasHeight - 160) / Math.max(nextLayerSize, 1), 40);
                        const nextStartY = canvasHeight/2 - (nextLayerSize - 1) * nextSpacing / 2;
                        
                        for (let i = 0; i < layerSize; i++) {
                            for (let j = 0; j < nextLayerSize; j++) {
                                const nextY = nextStartY + j * nextSpacing;
                                connections.push({
                                    from: { x, y: startY + i * spacing },
                                    to: { x: layerX[layerIdx + 1], y: nextY },
                                    fromLayer: layerIdx,
                                    toLayer: layerIdx + 1,
                                    fromNeuron: i,
                                    toNeuron: j
                                });
                            }
                        }
                    }
                });
            } catch (archError) {
                console.error("Architecture error:", archError);
                // Fallback for larger canvas
                const fallbackNeurons = [
                    [{ x: 80, y: canvasHeight/2 - 10, layer: 0, index: 0 }, { x: 80, y: canvasHeight/2 + 10, layer: 0, index: 1 }],
                    [{ x: canvasWidth/2, y: canvasHeight/2, layer: 1, index: 0 }],
                    [{ x: canvasWidth - 80, y: canvasHeight/2, layer: 2, index: 0 }]
                ];
                const fallbackConnections = [
                    { from: { x: 80, y: canvasHeight/2 - 10 }, to: { x: canvasWidth/2, y: canvasHeight/2 }, fromLayer: 0, toLayer: 1, fromNeuron: 0, toNeuron: 0 },
                    { from: { x: 80, y: canvasHeight/2 + 10 }, to: { x: canvasWidth/2, y: canvasHeight/2 }, fromLayer: 0, toLayer: 1, fromNeuron: 1, toNeuron: 0 },
                    { from: { x: canvasWidth/2, y: canvasHeight/2 }, to: { x: canvasWidth - 80, y: canvasHeight/2 }, fromLayer: 1, toLayer: 2, fromNeuron: 0, toNeuron: 0 }
                ];
                return { neurons: fallbackNeurons, connections: fallbackConnections, layers: [2, 1, 1] };
            }

            return { neurons, connections, layers };
        }

        // Draw functions
        function drawData() {
            dataCtx.fillStyle = 'white';
            dataCtx.fillRect(0, 0, 250, 220);

            trainingData.forEach(point => {
                dataCtx.beginPath();
                dataCtx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                
                if (problemType === 'classification') {
                    dataCtx.fillStyle = point.label ? '#3498db' : '#e74c3c';
                } else {
                    const intensity = Math.max(0, Math.min(1, point.label));
                    const red = Math.floor(255 * (1 - intensity));
                    const blue = Math.floor(255 * intensity);
                    dataCtx.fillStyle = `rgb(${red}, 100, ${blue})`;
                }
                
                dataCtx.fill();
                dataCtx.strokeStyle = 'white';
                dataCtx.lineWidth = 1;
                dataCtx.stroke();
            });
        }

        function drawNetwork() {
            const canvasWidth = networkCanvas.width;
            const canvasHeight = networkCanvas.height;
            
            networkCtx.fillStyle = 'white';
            networkCtx.fillRect(0, 0, canvasWidth, canvasHeight);

            const { neurons, connections } = getNetworkArchitecture();
            
            // Always draw connections first
            connections.forEach(conn => {
                let strokeStyle = '#bdc3c7';
                let lineWidth = 1.5;
                let isFlashing = conn.isFlashingBackward || false;
                
                // Apply weight visualization if enabled
                if (showWeights && currentWeights && Array.isArray(currentWeights)) {
                    if (conn.fromLayer < currentWeights.length && 
                        currentWeights[conn.fromLayer] && 
                        Array.isArray(currentWeights[conn.fromLayer])) {
                        
                        const layerWeights = currentWeights[conn.fromLayer];
                        const toLayerNeuronCount = neurons[conn.toLayer] ? neurons[conn.toLayer].length : 0;
                        
                        if (toLayerNeuronCount > 0) {
                            const weightIndex = conn.fromNeuron * toLayerNeuronCount + conn.toNeuron;
                            
                            if (weightIndex < layerWeights.length) {
                                const weight = layerWeights[weightIndex];
                                
                                if (typeof weight === 'number' && isFinite(weight)) {
                                    const absWeight = Math.abs(weight);
                                    
                                    // Color based on weight sign
                                    let R, G, B;
                                    if (weight > 0) { 
                                        R = 100; G = 150; B = 255; // Blue for positive
                                    } else { 
                                        R = 255; G = 100; B = 50;  // Red for negative
                                    }
                                    
                                    const baseOpacity = 0.3;
                                    const dynamicOpacity = Math.min(absWeight * 2, 0.9);
                                    const opacity = Math.max(baseOpacity, dynamicOpacity);

                                    const baseLineWidth = 1; 
                                    const dynamicLineWidth = absWeight * 10; 
                                    lineWidth = Math.max(baseLineWidth, Math.min(dynamicLineWidth, 8)); 

                                    // Pulsing effect during training
                                    if (isTraining) {
                                        const pulseFactor = 1 + 0.3 * Math.sin(epoch * 0.4 + conn.fromNeuron * 0.7 + conn.toNeuron * 0.5);
                                        lineWidth *= pulseFactor;
                                    }
                                    
                                    if (!isFlashing) {
                                        strokeStyle = `rgba(${R}, ${G}, ${B}, ${opacity})`;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Override for flashing
                if (isFlashing) {
                    strokeStyle = `rgba(255, 165, 0, 0.9)`;
                    lineWidth = Math.max(4, lineWidth * 1.5);
                }
                
                networkCtx.beginPath();
                networkCtx.moveTo(conn.from.x, conn.from.y);
                networkCtx.lineTo(conn.to.x, conn.to.y);
                networkCtx.strokeStyle = strokeStyle;
                networkCtx.lineWidth = lineWidth;
                if (isFlashing) {
                    networkCtx.setLineDash([5, 5]);
                } else {
                    networkCtx.setLineDash([]);
                }
                networkCtx.stroke();
                networkCtx.setLineDash([]);
            });

            // Draw neurons with larger size for bigger canvas
            neurons.forEach((layer, layerIdx) => {
                layer.forEach((neuron, neuronIdx) => {
                    // Get activation value if available
                    let activation = 0;
                    if (currentActivations && Array.isArray(currentActivations) && 
                        currentActivations[layerIdx] && Array.isArray(currentActivations[layerIdx])) {
                        activation = currentActivations[layerIdx][neuronIdx] || 0;
                    }

                    // Neuron color based on layer type
                    let baseColor = layerIdx === 0 ? '#3498db' : 
                                   layerIdx === neurons.length - 1 ? '#e74c3c' : '#9b59b6';
                    
                    // Adjust color intensity based on activation if showing activations
                    if (showActivations && currentActivations && Array.isArray(currentActivations)) {
                        const intensity = Math.min(Math.abs(activation), 1);
                        networkCtx.globalAlpha = 0.4 + intensity * 0.6;
                    }

                    // Larger neurons for bigger canvas
                    const neuronRadius = 15;
                    networkCtx.beginPath();
                    networkCtx.arc(neuron.x, neuron.y, neuronRadius, 0, Math.PI * 2);
                    networkCtx.fillStyle = baseColor;
                    networkCtx.fill();
                    networkCtx.strokeStyle = '#2c3e50';
                    networkCtx.lineWidth = 3;
                    networkCtx.stroke();
                    networkCtx.globalAlpha = 1;

                    // Show activation values with better positioning
                    if (showActivations && currentActivations && Array.isArray(currentActivations) && 
                        currentActivations[layerIdx] && Array.isArray(currentActivations[layerIdx])) {
                        networkCtx.fillStyle = '#2c3e50';
                        networkCtx.font = '12px Arial';
                        networkCtx.textAlign = 'center';
                        networkCtx.fillText(activation.toFixed(2), neuron.x, neuron.y - 25);
                    }
                });
            });

            // Labels with better positioning for larger canvas
            networkCtx.fillStyle = '#2c3e50';
            networkCtx.font = '16px Arial';
            networkCtx.textAlign = 'center';
            if (hiddenLayers && Array.isArray(hiddenLayers)) {
                const layerX = [80, ...hiddenLayers.map((_, i) => 80 + (i + 1) * ((canvasWidth - 160) / (hiddenLayers.length + 1))), canvasWidth - 80];
                layerX.forEach((x, i) => {
                    const label = i === 0 ? 'Input Layer' : 
                                 i === layerX.length - 1 ? 'Output Layer' : 
                                 `Hidden Layer ${i}`;
                    networkCtx.fillText(label, x, canvasHeight - 20);
                });
            }
        }

        function drawOutput() {
            if (!model || trainingData.length === 0) return;

            const canvasWidth = outputCanvas.width;
            const canvasHeight = outputCanvas.height;
            const resolution = Math.max(2, Math.floor(canvasWidth / 40)); // Adjust resolution for smaller canvas
            
            outputCtx.fillStyle = 'white';
            outputCtx.fillRect(0, 0, canvasWidth, canvasHeight);

            // Predict on grid
            const gridInputs = [];
            for (let y = 0; y < canvasHeight; y += resolution) {
                for (let x = 0; x < canvasWidth; x += resolution) {
                    gridInputs.push([x / canvasWidth * (250/240), y / canvasHeight * (220/180)]);
                }
            }

            if (gridInputs.length === 0) return;

            try {
                tf.tidy(() => {
                    const inputs = tf.tensor2d(gridInputs);
                    const predictions = model.predict(inputs);
                    const predValues = predictions.dataSync();

                    const imageData = outputCtx.createImageData(canvasWidth, canvasHeight);
                    const data = imageData.data;

                    let idx = 0;
                    for (let y = 0; y < canvasHeight; y += resolution) {
                        for (let x = 0; x < canvasWidth; x += resolution) {
                            const pred = predValues[idx++];
                            
                            for (let dy = 0; dy < resolution && y + dy < canvasHeight; dy++) {
                                for (let dx = 0; dx < resolution && x + dx < canvasWidth; dx++) {
                                    const pixelIdx = ((y + dy) * canvasWidth + (x + dx)) * 4;
                                    
                                    if (problemType === 'classification') {
                                        if (pred > 0.5) {
                                            data[pixelIdx] = 180; data[pixelIdx + 1] = 200; data[pixelIdx + 2] = 255;
                                        } else {
                                            data[pixelIdx] = 255; data[pixelIdx + 1] = 180; data[pixelIdx + 2] = 180;
                                        }
                                    } else {
                                        const clampedPred = Math.max(0, Math.min(1, pred));
                                        const intensity = clampedPred;
                                        const red = Math.floor(255 * (1 - intensity));
                                        const blue = Math.floor(255 * intensity);
                                        data[pixelIdx] = red;
                                        data[pixelIdx + 1] = 100;
                                        data[pixelIdx + 2] = blue;
                                    }
                                    data[pixelIdx + 3] = 255;
                                }
                            }
                        }
                    }
                    
                    outputCtx.putImageData(imageData, 0, 0);
                });
            } catch (error) {
                console.error('Prediction error:', error);
            }

            // Draw data points on top (scaled to corner canvas size)
            const scaleX = canvasWidth / 250;
            const scaleY = canvasHeight / 220;
            
            trainingData.forEach(point => {
                const scaledX = point.x * scaleX;
                const scaledY = point.y * scaleY;
                
                outputCtx.beginPath();
                outputCtx.arc(scaledX, scaledY, 2, 0, Math.PI * 2); // Smaller points for corner overlay
                
                if (problemType === 'classification') {
                    outputCtx.fillStyle = point.label ? '#3498db' : '#e74c3c';
                } else {
                    const intensity = Math.max(0, Math.min(1, point.label));
                    const red = Math.floor(255 * (1 - intensity));
                    const blue = Math.floor(255 * intensity);
                    outputCtx.fillStyle = `rgb(${red}, 100, ${blue})`;
                }
                
                outputCtx.fill();
                outputCtx.strokeStyle = 'white';
                outputCtx.lineWidth = 1;
                outputCtx.stroke();
            });
        }

        function initializeLossPlot() {
            const canvasWidth = lossCanvas.width;
            const canvasHeight = lossCanvas.height;
            
            lossCtx.fillStyle = '#ffffff';
            lossCtx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // Minimal grid
            lossCtx.strokeStyle = 'rgba(74, 144, 226, 0.1)';
            lossCtx.lineWidth = 1;
            lossCtx.setLineDash([2, 2]);
            
            // Vertical grid lines
            for (let i = 1; i < 5; i++) {
                const x = (canvasWidth / 5) * i;
                lossCtx.beginPath();
                lossCtx.moveTo(x, 20);
                lossCtx.lineTo(x, canvasHeight - 30);
                lossCtx.stroke();
            }
            
            // Horizontal grid lines
            for (let i = 1; i < 4; i++) {
                const y = 20 + ((canvasHeight - 50) / 4) * i;
                lossCtx.beginPath();
                lossCtx.moveTo(40, y);
                lossCtx.lineTo(canvasWidth - 20, y);
                lossCtx.stroke();
            }
            
            lossCtx.setLineDash([]);
            
            // Clean axes
            lossCtx.strokeStyle = 'rgba(74, 144, 226, 0.4)';
            lossCtx.lineWidth = 2;
            lossCtx.beginPath();
            // X-axis
            lossCtx.moveTo(40, canvasHeight - 30);
            lossCtx.lineTo(canvasWidth - 20, canvasHeight - 30);
            // Y-axis
            lossCtx.moveTo(40, 20);
            lossCtx.lineTo(40, canvasHeight - 30);
            lossCtx.stroke();
            
            // Minimal labels
            lossCtx.fillStyle = 'rgba(74, 144, 226, 0.8)';
            lossCtx.font = 'bold 12px Inter, sans-serif';
            lossCtx.textAlign = 'center';
            lossCtx.fillText('Loss Over Time', canvasWidth / 2, 15);
            
            lossCtx.font = '10px Inter, sans-serif';
            lossCtx.fillText('Epochs', canvasWidth / 2, canvasHeight - 5);
            
            lossCtx.save();
            lossCtx.translate(15, canvasHeight / 2);
            lossCtx.rotate(-Math.PI/2);
            lossCtx.fillText('Loss', 0, 0);
            lossCtx.restore();
        }

        function updateLossPlot() {
            if (lossHistory.length < 2) return;
            
            // Reinitialize background
            initializeLossPlot();
            
            const canvasWidth = lossCanvas.width;
            const canvasHeight = lossCanvas.height;
            const plotWidth = canvasWidth - 60;
            const plotHeight = canvasHeight - 50;
            
            // Auto-scale functionality
            let viewData = lossHistory;
            let startIndex = 0;
            
            if (autoScaleEnabled && lossHistory.length > recentLossWindow) {
                // Focus on recent data for better visibility
                startIndex = lossHistory.length - recentLossWindow;
                viewData = lossHistory.slice(startIndex);
            } else if (!autoScaleEnabled) {
                // Use zoom parameters when auto-scale is off
                viewData = lossHistory.slice(lossViewStart, lossViewEnd);
                startIndex = lossViewStart;
            }
            
            if (viewData.length === 0) return;
            
            // Auto-magnify: adjust Y-scale based on data range
            const viewMinLoss = Math.min(...viewData);
            const viewMaxLoss = Math.max(...viewData);
            let lossRange = viewMaxLoss - viewMinLoss;
            
            // Ensure minimum range for visibility
            if (lossRange < 0.01) {
                lossRange = 0.01;
                const midPoint = (viewMaxLoss + viewMinLoss) / 2;
                const adjustedMin = midPoint - lossRange / 2;
                const adjustedMax = midPoint + lossRange / 2;
            } else {
                // Add 10% padding for better visualization
                const padding = lossRange * 0.1;
                lossRange = lossRange + 2 * padding;
            }
            
            // Draw smooth loss curve
            lossCtx.strokeStyle = '#4A90E2';
            lossCtx.lineWidth = 3;
            lossCtx.lineCap = 'round';
            lossCtx.lineJoin = 'round';
            lossCtx.beginPath();
            
            // Create smooth curve
            const points = [];
            viewData.forEach((loss, i) => {
                const x = 40 + (i / Math.max(viewData.length - 1, 1)) * plotWidth;
                const y = (canvasHeight - 30) - ((loss - viewMinLoss) / lossRange) * plotHeight;
                points.push({ x, y, loss });
            });
            
            if (points.length > 0) {
                lossCtx.moveTo(points[0].x, points[0].y);
                
                if (points.length > 2) {
                    // Smooth curve using quadratic curves
                    for (let i = 1; i < points.length - 1; i++) {
                        const xMid = (points[i].x + points[i + 1].x) / 2;
                        const yMid = (points[i].y + points[i + 1].y) / 2;
                        lossCtx.quadraticCurveTo(points[i].x, points[i].y, xMid, yMid);
                    }
                    lossCtx.lineTo(points[points.length - 1].x, points[points.length - 1].y);
                } else {
                    points.forEach(point => lossCtx.lineTo(point.x, point.y));
                }
            }
            
            lossCtx.stroke();
            
            // Add gradient fill under the curve
            if (points.length > 0) {
                lossCtx.globalAlpha = 0.2;
                lossCtx.fillStyle = '#4A90E2';
                lossCtx.beginPath();
                lossCtx.moveTo(points[0].x, canvasHeight - 30);
                points.forEach(point => lossCtx.lineTo(point.x, point.y));
                lossCtx.lineTo(points[points.length - 1].x, canvasHeight - 30);
                lossCtx.closePath();
                lossCtx.fill();
                lossCtx.globalAlpha = 1;
            }
            
            // Highlight current point
            if (points.length > 0) {
                const currentPoint = points[points.length - 1];
                lossCtx.beginPath();
                lossCtx.arc(currentPoint.x, currentPoint.y, 6, 0, Math.PI * 2);
                lossCtx.fillStyle = '#F5A623';
                lossCtx.fill();
                lossCtx.strokeStyle = '#ffffff';
                lossCtx.lineWidth = 2;
                lossCtx.stroke();
                
                // Show current value
                lossCtx.fillStyle = 'rgba(74, 144, 226, 0.9)';
                lossCtx.font = 'bold 11px Inter, sans-serif';
                lossCtx.textAlign = 'center';
                lossCtx.fillText(currentPoint.loss.toFixed(4), currentPoint.x, currentPoint.y - 15);
            }
            
            // Update range display
            lossRangeSpan.textContent = `${viewMinLoss.toFixed(4)} - ${viewMaxLoss.toFixed(4)}`;
            
            // Dynamic axis labels
            lossCtx.fillStyle = 'rgba(74, 144, 226, 0.7)';
            lossCtx.font = '9px Inter, sans-serif';
            lossCtx.textAlign = 'right';
            
            // Y-axis labels
            for (let i = 0; i <= 3; i++) {
                const value = viewMaxLoss - (i / 3) * lossRange;
                const y = 20 + (i / 3) * plotHeight;
                lossCtx.fillText(value.toFixed(3), 35, y + 3);
            }
            
            // X-axis labels (epoch numbers)
            lossCtx.textAlign = 'center';
            const epochStep = Math.max(1, Math.floor(viewData.length / 4));
            for (let i = 0; i < viewData.length; i += epochStep) {
                const x = 40 + (i / Math.max(viewData.length - 1, 1)) * plotWidth;
                const epochNumber = startIndex + i;
                if (epochNumber % epochStep === 0) {
                    lossCtx.fillText(epochNumber.toString(), x, canvasHeight - 15);
                }
            }
            
            // Update zoom level display
            if (autoScaleEnabled) {
                zoomLevelSpan.textContent = `Auto (${recentLossWindow})`;
            } else {
                zoomLevelSpan.textContent = `${lossZoomLevel.toFixed(1)}x`;
            }
        }

        // Training
        async function toggleTraining() {
            if (isTraining) {
                isTraining = false;
                trainBtn.textContent = 'Start Training';
                trainBtn.style.backgroundColor = '#4A90E2';
                trainingStatusSpan.textContent = 'Stopped';
            } else {
                // Validation
                if (!trainingData || !Array.isArray(trainingData) || trainingData.length === 0) {
                    console.log('No training data available, generating data...');
                    generateData();
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                if (!trainingData || trainingData.length < 4) {
                    alert('Need at least 4 data points!');
                    return;
                }
                if (!model) {
                    console.log('No model available, creating model...');
                    createModel();
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                if (!model) {
                    console.error('Failed to create model');
                    return;
                }
                
                console.log(`Starting training with ${trainingData.length} data points`);
                isTraining = true;
                trainBtn.textContent = 'Stop Training';
                trainBtn.style.backgroundColor = '#e74c3c';
                trainingStatusSpan.textContent = 'Training...';
                await trainLoop();
            }
        }

        async function trainLoop() {
            while (isTraining) {
                try {
                    await trainStep();
                    // Use animation speed to control training speed (1=slowest, 10=fastest)
                    const delay = Math.max(5, 100 - (animationSpeed * 9));
                    await new Promise(resolve => setTimeout(resolve, delay));
                } catch (error) {
                    console.error('Training loop error:', error);
                    isTraining = false;
                    trainBtn.textContent = 'Start Training';
                    trainBtn.style.backgroundColor = '#4A90E2';
                    break;
                }
            }
        }

        async function trainStep() {
            // Validation
            if (!trainingData || !Array.isArray(trainingData) || trainingData.length === 0 || !model) {
                return;
            }

            let xs, ys;
            try {
                // Prepare input data with validation
                xs = [];
                ys = [];
                
                for (let i = 0; i < trainingData.length; i++) {
                    const point = trainingData[i];
                    if (!point || typeof point.x !== 'number' || typeof point.y !== 'number' || typeof point.label !== 'number') {
                        continue;
                    }
                    
                    const x_norm = point.x / 250;
                    const y_norm = point.y / 220;
                    const label = point.label;
                    
                    if (isNaN(x_norm) || isNaN(y_norm) || isNaN(label) || 
                        !isFinite(x_norm) || !isFinite(y_norm) || !isFinite(label)) {
                        continue;
                    }
                    
                    xs.push([x_norm, y_norm]);
                    ys.push([label]);
                }
                
                if (xs.length === 0) {
                    return;
                }
                
            } catch (error) {
                console.error('Data preparation error:', error);
                return;
            }

            let xsTensor, ysTensor;
            
            try {
                xsTensor = tf.tensor2d(xs);
                ysTensor = tf.tensor2d(ys);

                // Store weights before training for gradient calculation
                const weightsBefore = [];
                model.layers.forEach((layer, i) => {
                    if (layer && typeof layer.getWeights === 'function') {
                        const weights = layer.getWeights();
                        if (weights && weights.length > 0 && weights[0]) {
                            weightsBefore[i] = Array.from(weights[0].dataSync());
                        }
                    }
                });

                const history = await model.trainOnBatch(xsTensor, ysTensor);
                
                // Calculate gradients from weight changes
                const gradientValues = [];
                const weightUpdates = [];
                const lr = parseFloat(lrSlider.value);
                
                model.layers.forEach((layer, layerIdx) => {
                    if (layer && typeof layer.getWeights === 'function') {
                        const weights = layer.getWeights();
                        if (weights && weights.length > 0 && weights[0]) {
                            const currentWeights = Array.from(weights[0].dataSync());
                            const layerGrads = [];
                            
                            // Calculate weight updates and approximate gradients
                            if (weightsBefore[layerIdx]) {
                                for (let i = 0; i < Math.min(currentWeights.length, weightsBefore[layerIdx].length, 20); i++) {
                                    const weightUpdate = currentWeights[i] - weightsBefore[layerIdx][i];
                                    const gradient = -weightUpdate / lr; // Approximate gradient from weight update
                                    layerGrads.push(gradient);
                                    weightUpdates.push(weightUpdate);
                                }
                            }
                            
                            if (layerGrads.length > 0) {
                                gradientValues.push(layerGrads);
                            }
                        }
                    }
                });

                let loss, metric;
                
                if (Array.isArray(history)) {
                    loss = history[0];
                    metric = history[1];
                } else {
                    loss = history;
                    metric = null;
                }
                
                const lossValue = parseFloat(loss.toFixed(4));
                
                // Store gradients and display them
                currentGradients = gradientValues;
                if (epoch % 3 === 0) { // Update gradient display every 3 epochs for performance
                    displayGradientComputations(gradientValues, weightUpdates, lossValue);
                    updateMathDisplay(gradientValues, weightUpdates, lossValue, lr);
                    
                    // Update math visualization values
                    if (currentWeights && currentWeights[0]) {
                        currentMathValues.weights[0] = currentWeights[0].slice(0, 2);
                        currentMathValues.output = lossValue < 1 ? Math.random() * 0.8 + 0.1 : Math.random() * 0.3;
                        currentMathValues.loss = lossValue;
                        currentMathValues.gradient = gradientValues.length > 0 ? gradientValues[0][0] || 0 : 0;
                    }
                    updateMathValues();
                }
                
                // Update loss history
                lossHistory.push(lossValue);
                if (lossHistory.length > 1000) lossHistory.shift();
                
                minLoss = Math.min(minLoss, lossValue);
                maxLoss = Math.max(maxLoss, lossValue);
                
                epoch++;
                epochSpan.textContent = epoch;
                lossSpan.textContent = lossValue.toFixed(4);
                accuracySpan.textContent = metric ? metric.toFixed(3) : '-';
                currentLossSpan.textContent = lossValue.toFixed(4);
                minLossSpan.textContent = minLoss.toFixed(4);
                
                // Update weights for visualization
                if (showWeights && model && model.layers) {
                    updateCurrentWeights();
                }
                
                // Update visualizations
                if (epoch % 5 === 0) {
                    try {
                        drawOutput();
                        updateLossPlot();
                    } catch (vizError) {
                        console.error('Visualization error:', vizError);
                    }
                }
                
                // Update network visualization
                if (showWeights || showActivations) {
                    try {
                        if(showActivations && isTraining && trainingData.length > 0 && epoch % 10 === 0) {
                           tf.tidy(() => {
                                const sampleInput = tf.tensor2d([[trainingData[0].x / 250, trainingData[0].y / 220]]);
                                let currentProcessingTensor = sampleInput;
                                let activations = [[trainingData[0].x / 250, trainingData[0].y / 220]];
                                for (let i = 0; i < model.layers.length; i++) {
                                    currentProcessingTensor = model.layers[i].apply(currentProcessingTensor);
                                    activations.push(Array.from(currentProcessingTensor.dataSync()));
                                }
                                currentActivations = activations;
                           });
                        }
                        if (epoch % 5 === 0) {
                            drawNetwork();
                        }
                    } catch (networkError) {
                        console.error('Network visualization error:', networkError);
                    }
                }
                
            } catch (error) {
                console.error('Training step error:', error);
                throw error;
            } finally {
                if (xsTensor) xsTensor.dispose();
                if (ysTensor) ysTensor.dispose();
            }
        }

        function resetModel() {
            isTraining = false;
            trainBtn.textContent = 'Start Training';
            trainBtn.style.backgroundColor = '#4A90E2';
            trainingStatusSpan.textContent = 'Ready';
            currentActivations = null;
            currentWeights = null;
            console.log('Model reset');
            createModel();
        }

        function displayGradientComputations(gradients, weightUpdates, loss) {
            if (!gradients || gradients.length === 0) {
                layerGradientsDiv.innerHTML = '<p style="font-size: 0.8rem; color: #666; text-align: center;">No gradient data available</p>';
                return;
            }
            
            let html = '';
            
            // Calculate overall statistics
            let totalGradients = 0;
            let totalAbsGradients = 0;
            let totalWeightUpdates = 0;
            let totalAbsWeightUpdates = 0;
            
            gradients.forEach((layerGrads, layerIdx) => {
                if (layerGrads && layerGrads.length > 0) {
                    layerGrads.forEach(grad => {
                        totalGradients += grad;
                        totalAbsGradients += Math.abs(grad);
                    });
                }
            });
            
            if (weightUpdates) {
                weightUpdates.forEach(update => {
                    totalWeightUpdates += update;
                    totalAbsWeightUpdates += Math.abs(update);
                });
            }
            
            const avgGradient = totalAbsGradients / Math.max(1, gradients.flat().length);
            const avgWeightUpdate = totalAbsWeightUpdates / Math.max(1, weightUpdates ? weightUpdates.length : 1);
            const gradientNorm = Math.sqrt(totalAbsGradients);
            
            // Update overall stats
            lossGradientSpan.textContent = loss ? loss.toFixed(6) : '-';
            weightUpdateSpan.textContent = avgWeightUpdate.toFixed(6);
            gradientNormSpan.textContent = gradientNorm.toFixed(6);
            
            // Display layer-by-layer gradients
            gradients.forEach((layerGrads, layerIdx) => {
                if (!layerGrads || layerGrads.length === 0) return;
                
                html += `<div class="gradient-layer">`;
                html += `<h4>Layer ${layerIdx + 1} Gradients (∂L/∂w)</h4>`;
                html += `<div class="gradient-values">`;
                
                // Show first 12 gradients to avoid cluttering
                const gradsToShow = layerGrads.slice(0, 12);
                gradsToShow.forEach((grad, idx) => {
                    const absGrad = Math.abs(grad);
                    let className = 'gradient-value';
                    
                    if (grad > 0.001) className += ' positive';
                    else if (grad < -0.001) className += ' negative';
                    else className += ' zero';
                    
                    html += `<div class="${className}">
                        w${idx}: ${grad.toFixed(4)}
                    </div>`;
                });
                
                if (layerGrads.length > 12) {
                    html += `<div class="gradient-value">...+${layerGrads.length - 12} more</div>`;
                }
                
                html += `</div>`;
                
                // Show statistics for this layer
                const layerAvgGrad = layerGrads.reduce((sum, g) => sum + Math.abs(g), 0) / layerGrads.length;
                const layerMaxGrad = Math.max(...layerGrads.map(g => Math.abs(g)));
                const layerMinGrad = Math.min(...layerGrads.map(g => Math.abs(g)));
                
                html += `<div style="margin-top: 5px; font-size: 0.7rem; color: #666;">
                    Avg: ${layerAvgGrad.toFixed(5)} | Max: ${layerMaxGrad.toFixed(5)} | Min: ${layerMinGrad.toFixed(5)}
                </div>`;
                
                html += `</div>`;
            });
            
            // Add computation explanation
            html += `<div style="margin-top: 10px; padding: 8px; background-color: #e8f4f8; border-radius: 4px; font-size: 0.7rem;">
                <strong>Backprop Process:</strong><br>
                1. Compute loss: L = ${loss ? loss.toFixed(4) : 'calculating...'}<br>
                2. Calculate ∂L/∂w for each weight<br>
                3. Update: w_new = w_old - lr × ∂L/∂w<br>
                4. Gradient norm: ||∇|| = ${gradientNorm.toFixed(4)}
            </div>`;
            
            layerGradientsDiv.innerHTML = html;
            
            // Auto-scroll to bottom to see latest updates
            layerGradientsDiv.scrollTop = layerGradientsDiv.scrollHeight;
        }

        // Start when ready
        setTimeout(init, 1000);

        // Interactive gradient flow visualization
        function initializeGradientCanvas() {
            gradientCtx.fillStyle = 'white';
            gradientCtx.fillRect(0, 0, gradientCanvas.width, gradientCanvas.height);
            drawGradientDiagram();
        }

        function drawGradientDiagram() {
            const width = gradientCanvas.width;
            const height = gradientCanvas.height;
            
            gradientCtx.clearRect(0, 0, width, height);
            gradientCtx.fillStyle = 'white';
            gradientCtx.fillRect(0, 0, width, height);
            
            // Draw simplified network structure
            const layers = [2, hiddenLayers[0] || 8, 1];
            const layerX = [50, 200, 350];
            
            // Draw connections with gradient flow
            for (let i = 0; i < layers.length - 1; i++) {
                const currentLayerSize = layers[i];
                const nextLayerSize = layers[i + 1];
                const currentSpacing = Math.min(150 / currentLayerSize, 30);
                const nextSpacing = Math.min(150 / nextLayerSize, 30);
                const currentStartY = height/2 - (currentLayerSize - 1) * currentSpacing / 2;
                const nextStartY = height/2 - (nextLayerSize - 1) * nextSpacing / 2;
                
                for (let j = 0; j < currentLayerSize; j++) {
                    for (let k = 0; k < nextLayerSize; k++) {
                        const fromY = currentStartY + j * currentSpacing;
                        const toY = nextStartY + k * nextSpacing;
                        
                        // Draw connection
                        gradientCtx.beginPath();
                        gradientCtx.moveTo(layerX[i], fromY);
                        gradientCtx.lineTo(layerX[i + 1], toY);
                        gradientCtx.strokeStyle = '#e0e0e0';
                        gradientCtx.lineWidth = 1;
                        gradientCtx.stroke();
                        
                        // Draw gradient flow particles
                        if (gradientAnimationRunning || gradientAnimationStep > 0) {
                            drawGradientParticle(layerX[i + 1], toY, layerX[i], fromY, (gradientAnimationStep % 100) / 100);
                        }
                    }
                }
            }
            
            // Draw neurons
            for (let i = 0; i < layers.length; i++) {
                const layerSize = layers[i];
                const spacing = Math.min(150 / layerSize, 30);
                const startY = height/2 - (layerSize - 1) * spacing / 2;
                
                for (let j = 0; j < layerSize; j++) {
                    const y = startY + j * spacing;
                    gradientCtx.beginPath();
                    gradientCtx.arc(layerX[i], y, 12, 0, Math.PI * 2);
                    
                    if (i === 0) gradientCtx.fillStyle = '#3498db';
                    else if (i === layers.length - 1) gradientCtx.fillStyle = '#e74c3c';
                    else gradientCtx.fillStyle = '#9b59b6';
                    
                    gradientCtx.fill();
                    gradientCtx.strokeStyle = '#2c3e50';
                    gradientCtx.lineWidth = 2;
                    gradientCtx.stroke();
                }
            }
            
            // Draw labels
            gradientCtx.fillStyle = '#2c3e50';
            gradientCtx.font = '12px Arial';
            gradientCtx.textAlign = 'center';
            gradientCtx.fillText('Input', layerX[0], height - 10);
            gradientCtx.fillText('Hidden', layerX[1], height - 10);
            gradientCtx.fillText('Output', layerX[2], height - 10);
            
            // Draw gradient flow direction
            if (gradientAnimationRunning || gradientAnimationStep > 0) {
                gradientCtx.fillStyle = '#ff6b6b';
                gradientCtx.font = '14px Arial';
                gradientCtx.textAlign = 'left';
                gradientCtx.fillText('← Gradient Flow', 50, 30);
            }
        }

        function drawGradientParticle(fromX, fromY, toX, toY, progress) {
            const x = fromX + (toX - fromX) * progress;
            const y = fromY + (toY - fromY) * progress;
            
            gradientCtx.beginPath();
            gradientCtx.arc(x, y, 4, 0, Math.PI * 2);
            gradientCtx.fillStyle = `rgba(255, 107, 107, ${Math.sin(progress * Math.PI)})`;
            gradientCtx.fill();
        }

        function playGradientFlow() {
            gradientAnimationRunning = !gradientAnimationRunning;
            playGradientBtn.textContent = gradientAnimationRunning ? '⏸ Pause' : '▶ Play Gradient Flow';
            
            if (gradientAnimationRunning) {
                animateGradientFlow();
            }
        }

        function animateGradientFlow() {
            if (!gradientAnimationRunning) return;
            
            gradientAnimationStep += 2;
            drawGradientDiagram();
            
            requestAnimationFrame(animateGradientFlow);
        }

        function stepGradientFlow() {
            gradientAnimationStep += 10;
            drawGradientDiagram();
        }

        function resetGradientFlow() {
            gradientAnimationRunning = false;
            gradientAnimationStep = 0;
            playGradientBtn.textContent = '▶ Play Gradient Flow';
            drawGradientDiagram();
        }

        // Live math computation display (enhanced for visual system)
        function updateMathDisplay(gradients, weightUpdates, loss, lr) {
            mathSteps = [];
            
            if (!gradients || gradients.length === 0) {
                mathSteps.push('Waiting for gradient computation...');
            } else {
                mathSteps.push(`<strong>Step 1: Forward Pass</strong>`);
                mathSteps.push(`prediction = f(x) = σ(W·x + b)`);
                mathSteps.push(`loss = L(y_true, prediction) = ${loss ? loss.toFixed(4) : '?'}`);
                
                mathSteps.push(`<strong>Step 2: Backward Pass</strong>`);
                mathSteps.push(`∂L/∂prediction = ${loss ? (loss * 2).toFixed(4) : '?'}`);
                
                gradients.forEach((layerGrads, layerIdx) => {
                    if (layerGrads && layerGrads.length > 0) {
                        const avgGrad = layerGrads.reduce((sum, g) => sum + g, 0) / layerGrads.length;
                        mathSteps.push(`∂L/∂W${layerIdx + 1} = ${avgGrad.toFixed(6)} (avg)`);
                    }
                });
                
                mathSteps.push(`<strong>Step 3: Weight Update</strong>`);
                mathSteps.push(`learning_rate = ${lr}`);
                if (weightUpdates && weightUpdates.length > 0) {
                    const avgUpdate = weightUpdates.reduce((sum, u) => sum + u, 0) / weightUpdates.length;
                    mathSteps.push(`W_new = W_old - lr × ∂L/∂W`);
                    mathSteps.push(`ΔW = ${avgUpdate.toFixed(6)} (avg change)`);
                }
            }
            
            // Update live math values for visualization
            if (currentMathValues && gradients && gradients.length > 0) {
                currentMathValues.loss = loss || 0;
                currentMathValues.gradient = gradients[0] && gradients[0][0] ? gradients[0][0] : 0;
                currentMathValues.learningRate = lr;
                
                // Trigger canvas redraw if math animation is active
                if (mathAnimationRunning) {
                    drawMathVisualization();
                }
            }
        }

        function displayMathSteps() {
            let html = '';
            mathSteps.forEach((step, i) => {
                const className = i === mathSteps.length - 1 ? 'math-step highlight' : 'math-step';
                html += `<div class="${className}">${step}</div>`;
            });
            mathDisplayDiv.innerHTML = html;
            mathDisplayDiv.scrollTop = mathDisplayDiv.scrollHeight;
        }

        // Zoomable loss graph functions
        function zoomLoss(factor) {
            if (autoScaleEnabled) {
                // In auto mode, adjust the window size
                recentLossWindow = Math.max(10, Math.min(200, Math.floor(recentLossWindow / factor)));
            } else {
                // In manual mode, use traditional zoom
                lossZoomLevel *= factor;
                lossZoomLevel = Math.max(0.5, Math.min(10, lossZoomLevel));
                
                const historyLength = lossHistory.length;
                const viewWindow = Math.max(10, Math.floor(100 / lossZoomLevel));
                lossViewEnd = historyLength;
                lossViewStart = Math.max(0, lossViewEnd - viewWindow);
            }
            
            updateLossPlot();
        }

        function resetLossZoom() {
            lossZoomLevel = 1;
            lossViewStart = 0;
            lossViewEnd = lossHistory.length || 100;
            autoScaleEnabled = true;
            autoScaleBtn.textContent = '📈 Auto';
            autoScaleBtn.style.backgroundColor = '#4A90E2';
            zoomLevelSpan.textContent = 'Auto';
            updateLossPlot();
        }

        function toggleAutoScale() {
            autoScaleEnabled = !autoScaleEnabled;
            
            if (autoScaleEnabled) {
                autoScaleBtn.textContent = '📈 Auto';
                autoScaleBtn.style.backgroundColor = '#4A90E2';
                recentLossWindow = Math.min(50, lossHistory.length);
            } else {
                autoScaleBtn.textContent = '🔒 Manual';
                autoScaleBtn.style.backgroundColor = '#F5A623';
                // Switch to manual zoom mode
                lossViewStart = Math.max(0, lossHistory.length - 100);
                lossViewEnd = lossHistory.length;
            }
            
            updateLossPlot();
        }

        // Draggable overlay functionality
        function initializeDraggableOverlays() {
            const decisionBoundaryOverlay = document.getElementById('decision-boundary-overlay');
            const lossPlotOverlay = document.getElementById('loss-plot-overlay');
            
            // Add drag event listeners to both overlays
            addDragListeners(decisionBoundaryOverlay, 'decisionBoundary');
            addDragListeners(lossPlotOverlay, 'lossPlot');
        }

        function addDragListeners(element, overlayType) {
            let isDraggingElement = false;
            let startX, startY, startLeft, startTop;
            
            // Double-click to reset position
            element.addEventListener('dblclick', function(e) {
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'CANVAS') {
                    return;
                }
                resetSingleOverlayPosition(element, overlayType);
                e.preventDefault();
            });
            
            element.addEventListener('mousedown', function(e) {
                // Only start drag if clicking on the header or background, not on interactive elements
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'CANVAS') {
                    return;
                }
                
                isDraggingElement = true;
                element.classList.add('dragging');
                
                // Get mouse position relative to viewport
                startX = e.clientX;
                startY = e.clientY;
                
                // Get element position relative to viewport
                const rect = element.getBoundingClientRect();
                startLeft = rect.left;
                startTop = rect.top;
                
                // Convert to fixed positioning for viewport-wide dragging
                element.style.position = 'fixed';
                element.style.left = startLeft + 'px';
                element.style.top = startTop + 'px';
                element.style.margin = '0';
                element.style.zIndex = '1000';
                
                e.preventDefault();
                e.stopPropagation();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isDraggingElement) return;
                
                e.preventDefault();
                
                // Calculate new position relative to viewport
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                let newLeft = startLeft + deltaX;
                let newTop = startTop + deltaY;
                
                // Constrain to viewport bounds
                const elementRect = element.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                const maxLeft = viewportWidth - elementRect.width;
                const maxTop = viewportHeight - elementRect.height;
                
                newLeft = Math.max(0, Math.min(newLeft, maxLeft));
                newTop = Math.max(0, Math.min(newTop, maxTop));
                
                // Apply new position
                element.style.left = newLeft + 'px';
                element.style.top = newTop + 'px';
                
                // Store position
                overlayPositions[overlayType] = { x: newLeft, y: newTop };
            });
            
            document.addEventListener('mouseup', function(e) {
                if (!isDraggingElement) return;
                
                isDraggingElement = false;
                element.classList.remove('dragging');
            });
        }

        function resetSingleOverlayPosition(element, overlayType) {
            element.style.position = 'static';
            element.style.left = 'auto';
            element.style.top = 'auto';
            element.style.margin = '';
            element.style.zIndex = 'auto';
            
            overlayPositions[overlayType] = { x: null, y: null };
        }

        function resetOverlayPositions() {
            const decisionBoundaryOverlay = document.getElementById('decision-boundary-overlay');
            const lossPlotOverlay = document.getElementById('loss-plot-overlay');
            
            // Reset to default positions
            decisionBoundaryOverlay.style.position = 'relative';
            decisionBoundaryOverlay.style.left = 'auto';
            decisionBoundaryOverlay.style.top = 'auto';
            decisionBoundaryOverlay.style.right = 'auto';
            
            lossPlotOverlay.style.position = 'relative';
            lossPlotOverlay.style.left = 'auto';
            lossPlotOverlay.style.top = 'auto';
            lossPlotOverlay.style.right = 'auto';
            
            // Clear stored positions
            overlayPositions.decisionBoundary = { x: null, y: null };
            overlayPositions.lossPlot = { x: null, y: null };
        }

        // Visual Math Computation System
        let mathCanvas = null;
        let mathCtx = null;
        let mathAnimationRunning = false;
        let mathStep = 0;
        let mathSpeed = 1;
        let mathAnimationFrame = null;
        let currentMathValues = {
            input: [0.5, 0.3],
            weights: [[0.1, 0.2], [0.3, 0.4]],
            bias: [0.1, 0.2],
            output: 0,
            loss: 0,
            gradient: 0,
            learningRate: 0.01
        };

        // Math visualization initialization
        function initializeMathVisualization() {
            mathCanvas = document.getElementById('math-canvas');
            mathCtx = mathCanvas.getContext('2d');
            
            // Set up event listeners for math controls
            document.getElementById('math-play').addEventListener('click', toggleMathAnimation);
            document.getElementById('math-step').addEventListener('click', stepMathAnimation);
            document.getElementById('math-reset').addEventListener('click', resetMathAnimation);
            document.getElementById('math-speed').addEventListener('click', changeMathSpeed);
            
            // Add click listeners to equation steps
            document.querySelectorAll('.equation-step').forEach((step, index) => {
                step.addEventListener('click', () => setMathStep(index));
            });
            
            // Initialize math canvas
            drawMathVisualization();
            updateMathValues();
        }

        function toggleMathAnimation() {
            mathAnimationRunning = !mathAnimationRunning;
            const playBtn = document.getElementById('math-play');
            
            if (mathAnimationRunning) {
                playBtn.textContent = '⏸ Pause';
                playBtn.classList.add('playing');
                animateMathComputation();
            } else {
                playBtn.textContent = '▶ Auto Play';
                playBtn.classList.remove('playing');
                if (mathAnimationFrame) {
                    cancelAnimationFrame(mathAnimationFrame);
                }
            }
        }

        function stepMathAnimation() {
            mathStep = (mathStep + 1) % 6;
            updateMathStep();
            drawMathVisualization();
        }

        function resetMathAnimation() {
            mathStep = 0;
            mathAnimationRunning = false;
            document.getElementById('math-play').textContent = '▶ Auto Play';
            document.getElementById('math-play').classList.remove('playing');
            updateMathStep();
            drawMathVisualization();
        }

        function changeMathSpeed() {
            mathSpeed = mathSpeed === 3 ? 1 : mathSpeed + 1;
            document.getElementById('math-speed').textContent = `⚡ Speed: ${mathSpeed}x`;
        }

        function animateMathComputation() {
            if (!mathAnimationRunning) return;
            
            // Update step based on speed
            const frameDelay = 60 / mathSpeed; // Slower speeds = higher delay
            
            if (Date.now() % Math.floor(frameDelay) === 0) {
                mathStep = (mathStep + 1) % 6;
                updateMathStep();
                drawMathVisualization();
            }
            
            mathAnimationFrame = requestAnimationFrame(animateMathComputation);
        }

        function updateMathStep() {
            // Update equation step highlighting
            document.querySelectorAll('.equation-step').forEach((step, index) => {
                step.classList.toggle('active', index === mathStep);
            });
        }

        function setMathStep(step) {
            mathStep = step;
            updateMathStep();
            drawMathVisualization();
        }

        function drawMathVisualization() {
            const width = mathCanvas.width;
            const height = mathCanvas.height;
            
            // Clear canvas with gradient background
            mathCtx.fillStyle = 'white';
            mathCtx.fillRect(0, 0, width, height);
            
            // Add subtle background pattern
            mathCtx.strokeStyle = 'rgba(74, 144, 226, 0.05)';
            mathCtx.lineWidth = 1;
            for (let i = 0; i < width; i += 20) {
                mathCtx.beginPath();
                mathCtx.moveTo(i, 0);
                mathCtx.lineTo(i, height);
                mathCtx.stroke();
            }
            for (let i = 0; i < height; i += 20) {
                mathCtx.beginPath();
                mathCtx.moveTo(0, i);
                mathCtx.lineTo(width, i);
                mathCtx.stroke();
            }
            
            // Draw different visualizations based on current step
            switch (mathStep) {
                case 0: drawForwardPassVisualization(); break;
                case 1: drawActivationVisualization(); break;
                case 2: drawLossVisualization(); break;
                case 3: drawBackwardPassVisualization(); break;
                case 4: drawChainRuleVisualization(); break;
                case 5: drawWeightUpdateVisualization(); break;
            }
            
            // Draw step indicator
            drawStepIndicator();
        }

        function drawForwardPassVisualization() {
            const centerX = mathCanvas.width / 2;
            const centerY = mathCanvas.height / 2;
            
            // Draw input neurons
            const inputPositions = [
                { x: 80, y: centerY - 30, value: currentMathValues.input[0], label: 'x₁' },
                { x: 80, y: centerY + 30, value: currentMathValues.input[1], label: 'x₂' }
            ];
            
            // Draw hidden neuron
            const hiddenPos = { x: centerX, y: centerY, label: 'z = Σ(wᵢxᵢ) + b' };
            
            // Draw output neuron
            const outputPos = { x: mathCanvas.width - 80, y: centerY, value: currentMathValues.output, label: 'output' };
            
            // Draw connections with animated weights
            inputPositions.forEach((input, i) => {
                drawAnimatedConnection(input, hiddenPos, currentMathValues.weights[0][i], i);
            });
            drawAnimatedConnection(hiddenPos, outputPos, 0.5, 2);
            
            // Draw neurons
            inputPositions.forEach(pos => drawNeuron(pos.x, pos.y, pos.value, pos.label, '#3498db'));
            drawNeuron(hiddenPos.x, hiddenPos.y, 0.7, hiddenPos.label, '#9b59b6');
            drawNeuron(outputPos.x, outputPos.y, outputPos.value, outputPos.label, '#e74c3c');
            
            // Draw computation formula
            drawFormulaBox(centerX, 50, 'z = w₁x₁ + w₂x₂ + b', 'Forward Propagation');
            
            // Draw matrix multiplication visualization
            drawMatrixMultiplication(50, mathCanvas.height - 120);
        }

        function drawActivationVisualization() {
            const centerX = mathCanvas.width / 2;
            const centerY = mathCanvas.height / 2;
            
            // Draw activation function graph
            drawActivationFunction(centerX - 100, centerY - 80, 200, 120);
            
            // Draw input and output values
            const z = 0.7; // Example pre-activation value
            const a = 1 / (1 + Math.exp(-z)); // Sigmoid activation
            
            drawFormulaBox(centerX, 50, `σ(${z.toFixed(2)}) = ${a.toFixed(3)}`, 'Activation Function');
            
            // Draw visual representation of sigmoid
            drawSigmoidVisualization(centerX - 150, centerY + 100, 300, 60);
        }

        function drawLossVisualization() {
            const centerX = mathCanvas.width / 2;
            const centerY = mathCanvas.height / 2;
            
            // Draw loss function visualization
            const predicted = currentMathValues.output;
            const actual = 0.8; // Example target
            const loss = 0.5 * Math.pow(actual - predicted, 2);
            
            // Draw visual loss calculation
            drawLossCalculation(centerX - 100, centerY - 50, predicted, actual, loss);
            
            // Draw loss surface
            drawLossSurface(50, centerY + 80, 200, 100);
            
            drawFormulaBox(centerX, 50, `L = ½(y - ŷ)² = ${loss.toFixed(4)}`, 'Loss Calculation');
        }

        function drawBackwardPassVisualization() {
            const centerX = mathCanvas.width / 2;
            const centerY = mathCanvas.height / 2;
            
            // Draw gradient flow backwards
            drawGradientFlowDiagram(centerX, centerY);
            
            // Draw derivative calculation
            const dLoss_dOutput = -(0.8 - currentMathValues.output);
            drawFormulaBox(centerX, 50, `∂L/∂ŷ = -(y - ŷ) = ${dLoss_dOutput.toFixed(4)}`, 'Backward Pass');
            
            // Draw gradient arrows
            drawGradientArrows();
        }

        function drawChainRuleVisualization() {
            const centerX = mathCanvas.width / 2;
            const centerY = mathCanvas.height / 2;
            
            // Draw chain rule breakdown
            drawChainRuleBreakdown(centerX, centerY);
            
            drawFormulaBox(centerX, 50, '∂L/∂w = ∂L/∂a · ∂a/∂z · ∂z/∂w', 'Chain Rule');
        }

        function drawWeightUpdateVisualization() {
            const centerX = mathCanvas.width / 2;
            const centerY = mathCanvas.height / 2;
            
            // Draw weight update process
            drawWeightUpdateProcess(centerX, centerY);
            
            const weightUpdate = currentMathValues.learningRate * currentMathValues.gradient;
            drawFormulaBox(centerX, 50, `w_new = w_old - α·∇w = ${weightUpdate.toFixed(6)}`, 'Weight Update');
        }

        // Helper functions for drawing mathematical elements
        function drawNeuron(x, y, value, label, color) {
            const radius = 25;
            
            // Draw neuron circle
            mathCtx.beginPath();
            mathCtx.arc(x, y, radius, 0, Math.PI * 2);
            mathCtx.fillStyle = color;
            mathCtx.fill();
            mathCtx.strokeStyle = '#2c3e50';
            mathCtx.lineWidth = 3;
            mathCtx.stroke();
            
            // Draw value inside
            mathCtx.fillStyle = 'white';
            mathCtx.font = 'bold 12px Arial';
            mathCtx.textAlign = 'center';
            mathCtx.fillText(value.toFixed(2), x, y + 4);
            
            // Draw label below
            mathCtx.fillStyle = '#2c3e50';
            mathCtx.font = '10px Arial';
            mathCtx.fillText(label, x, y + radius + 15);
        }

        function drawAnimatedConnection(from, to, weight, index) {
            const thickness = Math.max(1, Math.abs(weight) * 8);
            const color = weight > 0 ? '#3498db' : '#e74c3c';
            const alpha = 0.3 + 0.7 * Math.abs(weight);
            
            mathCtx.beginPath();
            mathCtx.moveTo(from.x, from.y);
            mathCtx.lineTo(to.x, to.y);
            mathCtx.strokeStyle = color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
            mathCtx.lineWidth = thickness;
            mathCtx.stroke();
            
            // Draw weight value
            const midX = (from.x + to.x) / 2;
            const midY = (from.y + to.y) / 2;
            mathCtx.fillStyle = '#2c3e50';
            mathCtx.font = 'bold 10px Arial';
            mathCtx.textAlign = 'center';
            mathCtx.fillText(weight.toFixed(3), midX, midY - 10);
        }

        function drawFormulaBox(x, y, formula, title) {
            const width = 250;
            const height = 60;
            
            // Draw box
            mathCtx.fillStyle = 'rgba(74, 144, 226, 0.1)';
            mathCtx.fillRect(x - width/2, y - height/2, width, height);
            mathCtx.strokeStyle = '#4A90E2';
            mathCtx.lineWidth = 2;
            mathCtx.strokeRect(x - width/2, y - height/2, width, height);
            
            // Draw title
            mathCtx.fillStyle = '#4A90E2';
            mathCtx.font = 'bold 12px Arial';
            mathCtx.textAlign = 'center';
            mathCtx.fillText(title, x, y - 10);
            
            // Draw formula
            mathCtx.fillStyle = '#2c3e50';
            mathCtx.font = 'bold 14px Courier New';
            mathCtx.fillText(formula, x, y + 10);
        }

        function drawMatrixMultiplication(x, y) {
            // Draw input matrix
            mathCtx.fillStyle = '#3498db';
            mathCtx.fillRect(x, y, 60, 40);
            mathCtx.fillStyle = 'white';
            mathCtx.font = '10px Arial';
            mathCtx.textAlign = 'center';
            mathCtx.fillText('[x₁, x₂]', x + 30, y + 25);
            
            // Draw multiplication symbol
            mathCtx.fillStyle = '#2c3e50';
            mathCtx.font = 'bold 16px Arial';
            mathCtx.fillText('×', x + 80, y + 25);
            
            // Draw weight matrix
            mathCtx.fillStyle = '#9b59b6';
            mathCtx.fillRect(x + 100, y, 60, 40);
            mathCtx.fillStyle = 'white';
            mathCtx.font = '10px Arial';
            mathCtx.fillText('[W]', x + 130, y + 25);
            
            // Draw equals and result
            mathCtx.fillStyle = '#2c3e50';
            mathCtx.font = 'bold 16px Arial';
            mathCtx.fillText('=', x + 180, y + 25);
            
            mathCtx.fillStyle = '#e74c3c';
            mathCtx.fillRect(x + 200, y, 60, 40);
            mathCtx.fillStyle = 'white';
            mathCtx.font = '10px Arial';
            mathCtx.fillText('[z]', x + 230, y + 25);
        }

        function drawActivationFunction(x, y, width, height) {
            // Draw sigmoid curve
            mathCtx.strokeStyle = '#4A90E2';
            mathCtx.lineWidth = 3;
            mathCtx.beginPath();
            
            for (let i = 0; i <= width; i += 2) {
                const t = (i / width) * 12 - 6; // Range from -6 to 6
                const sigmoid = 1 / (1 + Math.exp(-t));
                const plotY = y + height - (sigmoid * height);
                
                if (i === 0) {
                    mathCtx.moveTo(x + i, plotY);
                } else {
                    mathCtx.lineTo(x + i, plotY);
                }
            }
            mathCtx.stroke();
            
            // Draw axes
            mathCtx.strokeStyle = '#2c3e50';
            mathCtx.lineWidth = 1;
            mathCtx.beginPath();
            mathCtx.moveTo(x, y + height);
            mathCtx.lineTo(x + width, y + height);
            mathCtx.moveTo(x, y);
            mathCtx.lineTo(x, y + height);
            mathCtx.stroke();
            
            // Labels
            mathCtx.fillStyle = '#2c3e50';
            mathCtx.font = '10px Arial';
            mathCtx.textAlign = 'center';
            mathCtx.fillText('σ(z)', x + width/2, y - 10);
        }

        function drawSigmoidVisualization(x, y, width, height) {
            // Draw input value visualization
            const inputValue = 0.7;
            const outputValue = 1 / (1 + Math.exp(-inputValue));
            
            // Input arrow
            mathCtx.strokeStyle = '#3498db';
            mathCtx.lineWidth = 3;
            mathCtx.beginPath();
            mathCtx.moveTo(x, y + height/2);
            mathCtx.lineTo(x + width/3, y + height/2);
            mathCtx.stroke();
            
            // Sigmoid box
            mathCtx.fillStyle = '#9b59b6';
            mathCtx.fillRect(x + width/3, y, width/3, height);
            mathCtx.fillStyle = 'white';
            mathCtx.font = 'bold 12px Arial';
            mathCtx.textAlign = 'center';
            mathCtx.fillText('σ', x + width/2, y + height/2 + 4);
            
            // Output arrow
            mathCtx.strokeStyle = '#e74c3c';
            mathCtx.lineWidth = 3;
            mathCtx.beginPath();
            mathCtx.moveTo(x + 2*width/3, y + height/2);
            mathCtx.lineTo(x + width, y + height/2);
            mathCtx.stroke();
            
            // Values
            mathCtx.fillStyle = '#2c3e50';
            mathCtx.font = '10px Arial';
            mathCtx.fillText(inputValue.toFixed(2), x + width/6, y + height + 15);
            mathCtx.fillText(outputValue.toFixed(3), x + 5*width/6, y + height + 15);
        }

        function drawLossCalculation(x, y, predicted, actual, loss) {
            const boxWidth = 200;
            const boxHeight = 100;
            
            // Draw comparison visualization
            const barHeight = 60;
            const barWidth = 30;
            
            // Actual value bar
            mathCtx.fillStyle = '#2ecc71';
            mathCtx.fillRect(x, y + boxHeight - actual * barHeight, barWidth, actual * barHeight);
            mathCtx.fillStyle = '#2c3e50';
            mathCtx.font = '10px Arial';
            mathCtx.textAlign = 'center';
            mathCtx.fillText('Actual', x + barWidth/2, y + boxHeight + 15);
            mathCtx.fillText(actual.toFixed(2), x + barWidth/2, y + boxHeight + 30);
            
            // Predicted value bar
            mathCtx.fillStyle = '#e74c3c';
            mathCtx.fillRect(x + 50, y + boxHeight - predicted * barHeight, barWidth, predicted * barHeight);
            mathCtx.fillText('Predicted', x + 50 + barWidth/2, y + boxHeight + 15);
            mathCtx.fillText(predicted.toFixed(2), x + 50 + barWidth/2, y + boxHeight + 30);
            
            // Loss visualization
            const diff = Math.abs(actual - predicted);
            mathCtx.fillStyle = `rgba(231, 76, 60, ${diff})`;
            mathCtx.fillRect(x + 120, y + 20, 60, 60);
            mathCtx.fillStyle = 'white';
            mathCtx.font = 'bold 12px Arial';
            mathCtx.fillText('Loss', x + 150, y + 45);
            mathCtx.fillText(loss.toFixed(4), x + 150, y + 60);
        }

        function drawLossSurface(x, y, width, height) {
            // Draw a simple 2D loss surface
            const ctx = mathCtx;
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            
            for (let i = 0; i < width; i++) {
                for (let j = 0; j < height; j++) {
                    const w1 = (i / width) * 4 - 2; // Weight 1 range: -2 to 2
                    const w2 = (j / height) * 4 - 2; // Weight 2 range: -2 to 2
                    
                    // Simple quadratic loss surface
                    const loss = (w1 * w1 + w2 * w2) / 8;
                    const intensity = Math.min(255, loss * 255);
                    
                    const pixelIdx = (j * width + i) * 4;
                    data[pixelIdx] = intensity; // Red
                    data[pixelIdx + 1] = 0; // Green
                    data[pixelIdx + 2] = 255 - intensity; // Blue
                    data[pixelIdx + 3] = 255; // Alpha
                }
            }
            
            ctx.putImageData(imageData, x, y);
            
            // Draw current position
            const currentW1 = currentMathValues.weights[0][0];
            const currentW2 = currentMathValues.weights[0][1];
            const posX = x + ((currentW1 + 2) / 4) * width;
            const posY = y + ((currentW2 + 2) / 4) * height;
            
            ctx.beginPath();
            ctx.arc(posX, posY, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#F5A623';
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawGradientFlowDiagram(centerX, centerY) {
            // Draw simplified network with gradient flow
            const neurons = [
                { x: centerX - 150, y: centerY, label: 'Input' },
                { x: centerX, y: centerY, label: 'Hidden' },
                { x: centerX + 150, y: centerY, label: 'Output' }
            ];
            
            // Draw connections with gradient flow animation
            for (let i = 0; i < neurons.length - 1; i++) {
                drawGradientFlow(neurons[i + 1], neurons[i]); // Backward direction
            }
            
            // Draw neurons
            neurons.forEach((neuron, i) => {
                const color = i === 0 ? '#3498db' : i === neurons.length - 1 ? '#e74c3c' : '#9b59b6';
                drawNeuron(neuron.x, neuron.y, 0.5, neuron.label, color);
            });
        }

        function drawGradientFlow(from, to) {
            // Draw arrow showing gradient flow
            mathCtx.strokeStyle = '#ff6b6b';
            mathCtx.lineWidth = 4;
            mathCtx.beginPath();
            mathCtx.moveTo(from.x, from.y);
            mathCtx.lineTo(to.x, to.y);
            mathCtx.stroke();
            
            // Draw arrowhead
            const angle = Math.atan2(to.y - from.y, to.x - from.x);
            const arrowLength = 15;
            
            mathCtx.beginPath();
            mathCtx.moveTo(to.x, to.y);
            mathCtx.lineTo(
                to.x - arrowLength * Math.cos(angle - Math.PI/6),
                to.y - arrowLength * Math.sin(angle - Math.PI/6)
            );
            mathCtx.moveTo(to.x, to.y);
            mathCtx.lineTo(
                to.x - arrowLength * Math.cos(angle + Math.PI/6),
                to.y - arrowLength * Math.sin(angle + Math.PI/6)
            );
            mathCtx.stroke();
        }

        function drawGradientArrows() {
            // Draw animated gradient arrows
            const time = Date.now() * 0.005;
            const arrows = [
                { x: 200, y: 150, dx: -50, dy: 0 },
                { x: 350, y: 150, dx: -50, dy: 0 },
                { x: 500, y: 150, dx: -50, dy: 0 }
            ];
            
            arrows.forEach((arrow, i) => {
                const offset = (Math.sin(time + i) + 1) * 10;
                mathCtx.fillStyle = `rgba(255, 107, 107, ${0.5 + 0.5 * Math.sin(time + i)})`;
                mathCtx.beginPath();
                mathCtx.moveTo(arrow.x + offset, arrow.y);
                mathCtx.lineTo(arrow.x + arrow.dx + offset, arrow.y + arrow.dy);
                mathCtx.lineTo(arrow.x + arrow.dx + offset + 10, arrow.y + arrow.dy - 5);
                mathCtx.lineTo(arrow.x + arrow.dx + offset, arrow.y + arrow.dy);
                mathCtx.lineTo(arrow.x + arrow.dx + offset + 10, arrow.y + arrow.dy + 5);
                mathCtx.fill();
            });
        }

        function drawChainRuleBreakdown(centerX, centerY) {
            const steps = [
                { text: '∂L/∂a', color: '#e74c3c', x: centerX - 120, y: centerY - 40 },
                { text: '∂a/∂z', color: '#9b59b6', x: centerX, y: centerY - 40 },
                { text: '∂z/∂w', color: '#3498db', x: centerX + 120, y: centerY - 40 }
            ];
            
            // Draw chain rule steps
            steps.forEach((step, i) => {
                mathCtx.fillStyle = step.color;
                mathCtx.fillRect(step.x - 40, step.y - 20, 80, 40);
                mathCtx.fillStyle = 'white';
                mathCtx.font = 'bold 12px Arial';
                mathCtx.textAlign = 'center';
                mathCtx.fillText(step.text, step.x, step.y + 4);
                
                // Draw multiplication symbols
                if (i < steps.length - 1) {
                    mathCtx.fillStyle = '#2c3e50';
                    mathCtx.font = 'bold 20px Arial';
                    mathCtx.fillText('×', step.x + 60, step.y + 4);
                }
            });
            
            // Draw result
            mathCtx.fillStyle = '#F5A623';
            mathCtx.fillRect(centerX - 60, centerY + 40, 120, 40);
            mathCtx.fillStyle = 'white';
            mathCtx.font = 'bold 12px Arial';
            mathCtx.fillText('∂L/∂w', centerX, centerY + 64);
            
            // Draw equals sign
            mathCtx.fillStyle = '#2c3e50';
            mathCtx.font = 'bold 20px Arial';
            mathCtx.fillText('=', centerX, centerY + 4);
        }

        function drawWeightUpdateProcess(centerX, centerY) {
            // Draw weight before and after
            const oldWeight = 0.5;
            const gradient = -0.1;
            const lr = 0.01;
            const newWeight = oldWeight - lr * gradient;
            
            // Old weight
            mathCtx.fillStyle = '#95a5a6';
            mathCtx.fillRect(centerX - 150, centerY - 30, 80, 60);
            mathCtx.fillStyle = 'white';
            mathCtx.font = 'bold 12px Arial';
            mathCtx.textAlign = 'center';
            mathCtx.fillText('w_old', centerX - 110, centerY - 5);
            mathCtx.fillText(oldWeight.toFixed(3), centerX - 110, centerY + 15);
            
            // Arrow with gradient
            mathCtx.strokeStyle = '#e74c3c';
            mathCtx.lineWidth = 3;
            mathCtx.beginPath();
            mathCtx.moveTo(centerX - 60, centerY);
            mathCtx.lineTo(centerX - 20, centerY);
            mathCtx.stroke();
            
            // Gradient value
            mathCtx.fillStyle = '#2c3e50';
            mathCtx.font = '10px Arial';
            mathCtx.fillText(`-α·∇w = ${(-lr * gradient).toFixed(5)}`, centerX - 40, centerY - 20);
            
            // New weight
            mathCtx.fillStyle = '#2ecc71';
            mathCtx.fillRect(centerX + 20, centerY - 30, 80, 60);
            mathCtx.fillStyle = 'white';
            mathCtx.font = 'bold 12px Arial';
            mathCtx.fillText('w_new', centerX + 60, centerY - 5);
            mathCtx.fillText(newWeight.toFixed(3), centerX + 60, centerY + 15);
        }

        function drawStepIndicator() {
            const steps = ['Forward', 'Activation', 'Loss', 'Backward', 'Chain Rule', 'Update'];
            const stepWidth = mathCanvas.width / steps.length;
            
            steps.forEach((step, i) => {
                const x = i * stepWidth;
                const isActive = i === mathStep;
                
                mathCtx.fillStyle = isActive ? '#4A90E2' : '#bdc3c7';
                mathCtx.fillRect(x, mathCanvas.height - 30, stepWidth - 2, 25);
                
                mathCtx.fillStyle = 'white';
                mathCtx.font = 'bold 10px Arial';
                mathCtx.textAlign = 'center';
                mathCtx.fillText(step, x + stepWidth/2, mathCanvas.height - 12);
            });
        }

        function updateMathValues() {
            if (!model || !trainingData || trainingData.length === 0) return;
            
            try {
                // Update values from current model state
                const samplePoint = trainingData[0];
                currentMathValues.input = [samplePoint.x / 250, samplePoint.y / 220];
                currentMathValues.learningRate = parseFloat(lrSlider.value);
                
                // Update display elements
                document.getElementById('math-input').textContent = 
                    `[${currentMathValues.input[0].toFixed(3)}, ${currentMathValues.input[1].toFixed(3)}]`;
                document.getElementById('math-weight').textContent = 
                    currentMathValues.weights[0][0].toFixed(4);
                document.getElementById('math-output').textContent = 
                    currentMathValues.output.toFixed(4);
                document.getElementById('math-loss').textContent = 
                    currentMathValues.loss.toFixed(6);
                document.getElementById('math-gradient').textContent = 
                    currentMathValues.gradient.toFixed(6);
                document.getElementById('math-lr').textContent = 
                    currentMathValues.learningRate.toFixed(4);
                
                // Add updating animation
                document.querySelectorAll('.value-box').forEach(box => {
                    box.classList.add('updating');
                    setTimeout(() => box.classList.remove('updating'), 800);
                });
                
            } catch (error) {
                console.error('Error updating math values:', error);
            }
        }

        // ========== ULTRA-INTERACTIVE MATH COMPUTATION SYSTEM ==========
        
        // Interactive state variables
        let currentInteractionMode = 'explore';
        let isScrubbingValue = false;
        let scrubStartX = 0;
        let scrubStartValue = 0;
        let selectedElements = new Set();
        let hoveredElement = null;
        let draggedElement = null;
        let lastRightClickTarget = null;
        let savedStates = [];
        let tutorialStep = 0;
        let keyboardShortcuts = {};

        // Interactive element data
        const interactiveElements = {
            'x1': { value: 0.5, min: -2, max: 2, type: 'input' },
            'x2': { value: 0.3, min: -2, max: 2, type: 'input' },
            'target': { value: 0.8, min: 0, max: 1, type: 'target' },
            'w11': { value: 0.1, min: -1, max: 1, type: 'weight' },
            'w12': { value: 0.2, min: -1, max: 1, type: 'weight' },
            'w21': { value: 0.3, min: -1, max: 1, type: 'weight' },
            'w22': { value: 0.4, min: -1, max: 1, type: 'weight' },
            'bias': { value: 0.1, min: -1, max: 1, type: 'bias' },
            'lr': { value: 0.01, min: 0.001, max: 0.1, type: 'learning-rate' },
            'momentum': { value: 0.9, min: 0, max: 1, type: 'momentum' }
        };

        // Tooltip information database
        const tooltipInfo = {
            'pre-activation': 'The linear combination z = W·x + b before applying activation function',
            'weight-matrix': 'Matrix of connection weights between layers',
            'input-vector': 'Input features fed into the neural network',
            'bias-term': 'Bias term added to shift the activation function',
            'activation-output': 'Output after applying the activation function σ(z)',
            'sigmoid-function': 'Sigmoid activation function: σ(z) = 1/(1+e^(-z))',
            'loss-value': 'Measures difference between prediction and target',
            'target-value': 'The desired output value',
            'prediction': 'Neural network\'s predicted output',
            'loss-gradient': 'Gradient of loss with respect to activation',
            'activation-derivative': 'Derivative of activation function',
            'weight-derivative': 'Derivative of pre-activation with respect to weights',
            'weight-gradient': 'Gradient of loss with respect to weights',
            'learning-rate': 'Step size for gradient descent updates',
            'old-weight': 'Weight value before update',
            'new-weight': 'Weight value after gradient descent update'
        };

        // Tutorial steps
        const tutorialSteps = [
            { title: 'Welcome!', content: 'This is an ultra-interactive neural network math playground. You can click, drag, edit, and manipulate everything!' },
            { title: 'Interaction Modes', content: 'Switch between Explore, Edit, Debug, and Tutorial modes using the buttons at the top.' },
            { title: 'Parameter Editing', content: 'Use the parameter panel to adjust inputs, weights, and training settings in real-time.' },
            { title: 'Clickable Equations', content: 'Click on any term in the equations to see detailed explanations and live values.' },
            { title: 'Value Scrubbing', content: 'Drag left/right on scrubable values to adjust them dynamically.' },
            { title: 'Computation Graph', content: 'The interactive graph shows how data flows through the network.' },
            { title: 'Hover for Details', content: 'Hover over any element to see tooltips with detailed information.' },
            { title: 'Right-Click Menus', content: 'Right-click on elements for additional options like inspect, edit, and explain.' },
            { title: 'Keyboard Shortcuts', content: 'Use keyboard shortcuts for power user features (hover to see shortcuts).' },
            { title: 'Save & Load', content: 'Save interesting parameter configurations and load them later!' }
        ];

        // Initialize ultra-interactive system
        function initializeUltraInteractiveSystem() {
            setupInteractionModes();
            setupParameterControls();
            setupEquationInteractions();
            setupComputationGraph();
            setupValueScrubbing();
            setupHoverTooltips();
            setupContextMenus();
            setupKeyboardShortcuts();
            setupCanvasInteractions();
            setupTutorialSystem();
            
            console.log('🚀 Ultra-Interactive Math Computation System initialized!');
        }

        // Mode switching system
        function setupInteractionModes() {
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    // Remove active class from all buttons
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    // Add active class to clicked button
                    this.classList.add('active');
                    
                    // Update current mode
                    currentInteractionMode = this.dataset.mode;
                    document.getElementById('current-mode').textContent = `Mode: ${this.dataset.mode.charAt(0).toUpperCase() + this.dataset.mode.slice(1)}`;
                    
                    // Apply mode-specific behaviors
                    applyInteractionMode(currentInteractionMode);
                });
            });
        }

        function applyInteractionMode(mode) {
            const allElements = document.querySelectorAll('.interactive-element, .clickable, .scrubable');
            
            switch(mode) {
                case 'explore':
                    document.getElementById('hover-info').textContent = 'Hover over elements for details';
                    allElements.forEach(el => {
                        el.style.cursor = 'pointer';
                        el.style.borderColor = 'transparent';
                    });
                    break;
                    
                case 'edit':
                    document.getElementById('hover-info').textContent = 'Click to edit • Drag to adjust';
                    allElements.forEach(el => {
                        el.style.cursor = 'text';
                        el.style.borderColor = '#4A90E2';
                    });
                    break;
                    
                case 'debug':
                    document.getElementById('hover-info').textContent = 'Debug mode: inspect computations';
                    allElements.forEach(el => {
                        el.style.cursor = 'crosshair';
                        el.style.borderColor = '#e74c3c';
                    });
                    break;
                    
                case 'tutorial':
                    document.getElementById('hover-info').textContent = 'Tutorial mode: guided learning';
                    showTutorial();
                    break;
            }
            
            updateInteractionHints();
        }

        // Parameter controls setup
        function setupParameterControls() {
            // Sync input fields with sliders
            Object.keys(interactiveElements).forEach(key => {
                const input = document.getElementById(`edit-${key}`) || document.getElementById(key);
                const slider = document.getElementById(`slider-${key}`);
                
                if (input) {
                    input.addEventListener('input', function() {
                        const value = parseFloat(this.value);
                        interactiveElements[key].value = value;
                        if (slider) slider.value = value;
                        updateComputations();
                        updateVisualizations();
                    });
                }
                
                if (slider) {
                    slider.addEventListener('input', function() {
                        const value = parseFloat(this.value);
                        interactiveElements[key].value = value;
                        if (input) input.value = value;
                        updateComputations();
                        updateVisualizations();
                    });
                }
            });

            // Weight visual interactions
            document.querySelectorAll('.weight-visual').forEach(visual => {
                visual.addEventListener('click', function() {
                    const weightKey = this.dataset.weight;
                    const currentValue = interactiveElements[weightKey].value;
                    const newValue = prompt(`Enter new value for ${weightKey}:`, currentValue);
                    if (newValue !== null && !isNaN(newValue)) {
                        interactiveElements[weightKey].value = parseFloat(newValue);
                        document.getElementById(weightKey).value = newValue;
                        updateComputations();
                        updateVisualizations();
                    }
                });
            });
        }

        // Interactive equation setup
        function setupEquationInteractions() {
            document.querySelectorAll('.math-term').forEach(term => {
                term.addEventListener('click', function() {
                    const info = this.dataset.info;
                    if (tooltipInfo[info]) {
                        showExplanationDialog(this.textContent, tooltipInfo[info]);
                    }
                });
                
                term.addEventListener('mouseenter', function() {
                    showTooltip(this, tooltipInfo[this.dataset.info]);
                });
                
                term.addEventListener('mouseleave', hideTooltip);
            });
        }

        // Computation graph interactions
        function setupComputationGraph() {
            document.querySelectorAll('.graph-node').forEach(node => {
                node.addEventListener('click', function() {
                    this.classList.toggle('selected');
                    highlightConnectedElements(this.dataset.node);
                });
                
                node.addEventListener('dblclick', function() {
                    const nodeType = this.dataset.node;
                    if (['x1', 'x2'].includes(nodeType)) {
                        const newValue = prompt(`Enter new value for ${nodeType}:`, interactiveElements[nodeType].value);
                        if (newValue !== null && !isNaN(newValue)) {
                            interactiveElements[nodeType].value = parseFloat(newValue);
                            updateComputations();
                            updateVisualizations();
                        }
                    }
                });
            });

            document.querySelectorAll('.graph-edge').forEach(edge => {
                edge.addEventListener('click', function() {
                    const edgeType = this.dataset.edge;
                    const weightKey = edgeType.replace('-', '').replace('x', 'w');
                    if (interactiveElements[weightKey]) {
                        const newValue = prompt(`Enter new weight value:`, interactiveElements[weightKey].value);
                        if (newValue !== null && !isNaN(newValue)) {
                            interactiveElements[weightKey].value = parseFloat(newValue);
                            updateComputations();
                            updateVisualizations();
                        }
                    }
                });
            });
        }

        // Value scrubbing system
        function setupValueScrubbing() {
            document.querySelectorAll('.scrubable').forEach(element => {
                element.addEventListener('mousedown', function(e) {
                    if (currentInteractionMode === 'edit') {
                        isScrubbingValue = true;
                        scrubStartX = e.clientX;
                        const valueKey = this.dataset.value;
                        scrubStartValue = interactiveElements[valueKey]?.value || 0;
                        
                        document.body.style.cursor = 'ew-resize';
                        e.preventDefault();
                    }
                });
            });

            document.addEventListener('mousemove', function(e) {
                if (isScrubbingValue) {
                    const deltaX = e.clientX - scrubStartX;
                    const sensitivity = 0.01;
                    const newValue = scrubStartValue + (deltaX * sensitivity);
                    
                    // Find the active scrubbing element
                    const scrubElement = document.querySelector('.scrubable:hover');
                    if (scrubElement) {
                        const valueKey = scrubElement.dataset.value;
                        const element = interactiveElements[valueKey];
                        if (element) {
                            element.value = Math.max(element.min, Math.min(element.max, newValue));
                            updateComputations();
                            updateVisualizations();
                        }
                    }
                }
            });

            document.addEventListener('mouseup', function() {
                if (isScrubbingValue) {
                    isScrubbingValue = false;
                    document.body.style.cursor = 'default';
                }
            });
        }

        // Hover tooltip system
        function setupHoverTooltips() {
            const tooltip = document.getElementById('hover-tooltip');
            
            document.addEventListener('mouseover', function(e) {
                if (e.target.dataset.info || e.target.dataset.tooltip) {
                    const info = e.target.dataset.info || e.target.dataset.tooltip;
                    showTooltip(e.target, tooltipInfo[info] || info);
                }
            });
            
            document.addEventListener('mouseout', function(e) {
                if (e.target.dataset.info || e.target.dataset.tooltip) {
                    hideTooltip();
                }
            });
        }

        function showTooltip(element, text) {
            if (!text) return;
            
            const tooltip = document.getElementById('hover-tooltip');
            const tooltipContent = tooltip.querySelector('.tooltip-content');
            
            tooltipContent.textContent = text;
            tooltip.classList.remove('hidden');
            
            // Position tooltip
            const rect = element.getBoundingClientRect();
            tooltip.style.left = rect.right + 10 + 'px';
            tooltip.style.top = rect.top + 'px';
            
            // Adjust if tooltip goes off screen
            const tooltipRect = tooltip.getBoundingClientRect();
            if (tooltipRect.right > window.innerWidth) {
                tooltip.style.left = rect.left - tooltipRect.width - 10 + 'px';
            }
            if (tooltipRect.bottom > window.innerHeight) {
                tooltip.style.top = rect.bottom - tooltipRect.height + 'px';
            }
        }

        function hideTooltip() {
            document.getElementById('hover-tooltip').classList.add('hidden');
        }

        // Context menu system
        function setupContextMenus() {
            const contextMenu = document.getElementById('context-menu');
            
            document.addEventListener('contextmenu', function(e) {
                if (e.target.classList.contains('interactive-element') || 
                    e.target.classList.contains('clickable') ||
                    e.target.classList.contains('scrubable')) {
                    
                    e.preventDefault();
                    lastRightClickTarget = e.target;
                    
                    contextMenu.style.left = e.clientX + 'px';
                    contextMenu.style.top = e.clientY + 'px';
                    contextMenu.classList.remove('hidden');
                }
            });
            
            document.addEventListener('click', function() {
                contextMenu.classList.add('hidden');
            });
        }

        // Keyboard shortcuts
        function setupKeyboardShortcuts() {
            keyboardShortcuts = {
                'Space': toggleMathAnimation,
                'ArrowRight': stepMathAnimation,
                'KeyR': resetMathAnimation,
                'KeyS': saveCurrentState,
                'KeyL': loadSavedState,
                'KeyT': () => applyInteractionMode('tutorial'),
                'KeyE': () => applyInteractionMode('edit'),
                'KeyD': () => applyInteractionMode('debug'),
                'Escape': () => applyInteractionMode('explore')
            };
            
            document.addEventListener('keydown', function(e) {
                if (!e.target.matches('input, textarea') && keyboardShortcuts[e.code]) {
                    e.preventDefault();
                    keyboardShortcuts[e.code]();
                }
            });
        }

        // Canvas interactions
        function setupCanvasInteractions() {
            mathCanvas.addEventListener('click', function(e) {
                const rect = this.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Handle canvas clicks based on current step and position
                handleCanvasClick(x, y);
            });
            
            mathCanvas.addEventListener('mousemove', function(e) {
                const rect = this.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Update cursor based on hoverable elements
                updateCanvasCursor(x, y);
            });
        }

        // Tutorial system
        function setupTutorialSystem() {
            document.getElementById('tutorial-prev').addEventListener('click', function() {
                tutorialStep = Math.max(0, tutorialStep - 1);
                updateTutorialDisplay();
            });
            
            document.getElementById('tutorial-next').addEventListener('click', function() {
                tutorialStep = Math.min(tutorialSteps.length - 1, tutorialStep + 1);
                updateTutorialDisplay();
            });
        }

        function showTutorial() {
            document.getElementById('tutorial-overlay').classList.remove('hidden');
            updateTutorialDisplay();
        }

        function hideTutorial() {
            document.getElementById('tutorial-overlay').classList.add('hidden');
        }

        function updateTutorialDisplay() {
            const step = tutorialSteps[tutorialStep];
            document.querySelector('.step-content').innerHTML = `
                <h6>${step.title}</h6>
                <p>${step.content}</p>
            `;
            document.getElementById('tutorial-progress').textContent = `${tutorialStep + 1} / ${tutorialSteps.length}`;
        }

        // Computation and visualization updates
        function updateComputations() {
            // Update all computed values based on current parameters
            const x1 = interactiveElements.x1.value;
            const x2 = interactiveElements.x2.value;
            const w11 = interactiveElements.w11.value;
            const w12 = interactiveElements.w12.value;
            const bias = interactiveElements.bias.value;
            const target = interactiveElements.target.value;
            
            // Forward pass computation
            const z = w11 * x1 + w12 * x2 + bias;
            const a = 1 / (1 + Math.exp(-z)); // Sigmoid
            const loss = 0.5 * Math.pow(target - a, 2);
            
            // Backward pass computation
            const dL_da = -(target - a);
            const da_dz = a * (1 - a); // Sigmoid derivative
            const dz_dw11 = x1;
            const dz_dw12 = x2;
            const dL_dw11 = dL_da * da_dz * dz_dw11;
            const dL_dw12 = dL_da * da_dz * dz_dw12;
            
            // Update computed values
            currentMathValues.input = [x1, x2];
            currentMathValues.output = a;
            currentMathValues.loss = loss;
            currentMathValues.gradient = dL_dw11; // Representative gradient
            
            // Update display elements
            updateDisplayValues();
        }

        function updateVisualizations() {
            // Update computation graph values
            document.getElementById('graph-x1').textContent = interactiveElements.x1.value.toFixed(2);
            document.getElementById('graph-x2').textContent = interactiveElements.x2.value.toFixed(2);
            document.getElementById('graph-z').textContent = (interactiveElements.w11.value * interactiveElements.x1.value + 
                                                              interactiveElements.w12.value * interactiveElements.x2.value + 
                                                              interactiveElements.bias.value).toFixed(2);
            document.getElementById('graph-a').textContent = currentMathValues.output.toFixed(3);
            document.getElementById('graph-loss').textContent = currentMathValues.loss.toFixed(4);
            
            // Update edge values
            document.getElementById('edge-w11').textContent = interactiveElements.w11.value.toFixed(2);
            document.getElementById('edge-w12').textContent = interactiveElements.w12.value.toFixed(2);
            
            // Update weight visuals
            updateWeightVisuals();
            
            // Redraw canvas if needed
            if (mathAnimationRunning || currentInteractionMode === 'debug') {
                drawMathVisualization();
            }
        }

        function updateDisplayValues() {
            document.getElementById('math-input').textContent = 
                `[${currentMathValues.input[0].toFixed(3)}, ${currentMathValues.input[1].toFixed(3)}]`;
            document.getElementById('math-weight').textContent = 
                interactiveElements.w11.value.toFixed(4);
            document.getElementById('math-output').textContent = 
                currentMathValues.output.toFixed(4);
            document.getElementById('math-loss').textContent = 
                currentMathValues.loss.toFixed(6);
            document.getElementById('math-gradient').textContent = 
                currentMathValues.gradient.toFixed(6);
            document.getElementById('math-lr').textContent = 
                interactiveElements.lr.value.toFixed(4);
        }

        function updateWeightVisuals() {
            document.querySelectorAll('.weight-visual').forEach(visual => {
                const weightKey = visual.dataset.weight;
                const value = interactiveElements[weightKey].value;
                const normalized = (value + 1) / 2; // Normalize to 0-1 range
                visual.style.setProperty('--weight-position', `${normalized * 100}%`);
            });
        }

        // Interactive helper functions
        function randomizeInput() {
            interactiveElements.x1.value = (Math.random() - 0.5) * 4;
            interactiveElements.x2.value = (Math.random() - 0.5) * 4;
            document.getElementById('edit-x1').value = interactiveElements.x1.value.toFixed(2);
            document.getElementById('edit-x2').value = interactiveElements.x2.value.toFixed(2);
            updateComputations();
            updateVisualizations();
        }

        function randomizeWeights() {
            ['w11', 'w12', 'w21', 'w22', 'bias'].forEach(key => {
                interactiveElements[key].value = (Math.random() - 0.5) * 2;
                const input = document.getElementById(key);
                if (input) input.value = interactiveElements[key].value.toFixed(3);
            });
            updateComputations();
            updateVisualizations();
        }

        function copyValue(valueType) {
            const value = getCurrentValue(valueType);
            navigator.clipboard.writeText(value).then(() => {
                showTemporaryMessage('Value copied to clipboard!');
            });
        }

        function getCurrentValue(valueType) {
            switch(valueType) {
                case 'input': return `[${currentMathValues.input[0].toFixed(3)}, ${currentMathValues.input[1].toFixed(3)}]`;
                case 'weight': return interactiveElements.w11.value.toFixed(4);
                case 'output': return currentMathValues.output.toFixed(4);
                case 'loss': return currentMathValues.loss.toFixed(6);
                case 'gradient': return currentMathValues.gradient.toFixed(6);
                case 'learning-rate': return interactiveElements.lr.value.toFixed(4);
                default: return '';
            }
        }

        function showDerivation(valueType) {
            let derivation = '';
            switch(valueType) {
                case 'output':
                    derivation = `Output Derivation:\na = σ(z) = σ(W·x + b)\na = 1 / (1 + e^(-z))\na = 1 / (1 + e^(-(${interactiveElements.w11.value.toFixed(3)}*${interactiveElements.x1.value.toFixed(3)} + ${interactiveElements.w12.value.toFixed(3)}*${interactiveElements.x2.value.toFixed(3)} + ${interactiveElements.bias.value.toFixed(3)})))\na = ${currentMathValues.output.toFixed(6)}`;
                    break;
                case 'loss':
                    derivation = `Loss Derivation:\nL = ½(y - a)²\nL = ½(${interactiveElements.target.value.toFixed(3)} - ${currentMathValues.output.toFixed(3)})²\nL = ½(${(interactiveElements.target.value - currentMathValues.output).toFixed(3)})²\nL = ${currentMathValues.loss.toFixed(6)}`;
                    break;
                case 'gradient':
                    derivation = `Gradient Derivation:\n∂L/∂w = ∂L/∂a · ∂a/∂z · ∂z/∂w\n∂L/∂a = -(y - a) = ${(-(interactiveElements.target.value - currentMathValues.output)).toFixed(6)}\n∂a/∂z = a(1-a) = ${(currentMathValues.output * (1 - currentMathValues.output)).toFixed(6)}\n∂z/∂w = x = ${interactiveElements.x1.value.toFixed(3)}\n∂L/∂w = ${currentMathValues.gradient.toFixed(6)}`;
                    break;
            }
            showExplanationDialog(`${valueType.charAt(0).toUpperCase() + valueType.slice(1)} Computation`, derivation);
        }

        function plotFunction(functionType) {
            // Create a simple popup showing the function plot
            alert(`Plotting ${functionType} function - Feature coming soon!`);
        }

        function visualizeGradient() {
            alert('Gradient visualization - Feature coming soon!');
        }

        function optimizeLR() {
            // Simple learning rate optimization
            const currentLoss = currentMathValues.loss;
            const testLR = interactiveElements.lr.value * 0.8;
            interactiveElements.lr.value = testLR;
            showTemporaryMessage(`Optimized learning rate to ${testLR.toFixed(4)}`);
            updateComputations();
            updateVisualizations();
        }

        function scheduleLR() {
            alert('Learning rate scheduling - Feature coming soon!');
        }

        function showExplanationDialog(title, content) {
            alert(`${title}\n\n${content}`);
        }

        function showTemporaryMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.textContent = message;
            messageDiv.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4A90E2; color: white; padding: 10px; border-radius: 5px; z-index: 9999; animation: fadeInOut 3s ease;';
            document.body.appendChild(messageDiv);
            setTimeout(() => messageDiv.remove(), 3000);
        }

        function saveCurrentState() {
            const state = {
                timestamp: new Date().toISOString(),
                parameters: { ...interactiveElements },
                mathValues: { ...currentMathValues }
            };
            savedStates.push(state);
            localStorage.setItem('mathPlaygroundStates', JSON.stringify(savedStates));
            showTemporaryMessage('State saved successfully!');
        }

        function loadSavedState() {
            const saved = localStorage.getItem('mathPlaygroundStates');
            if (saved) {
                savedStates = JSON.parse(saved);
                if (savedStates.length > 0) {
                    const lastState = savedStates[savedStates.length - 1];
                    Object.assign(interactiveElements, lastState.parameters);
                    Object.assign(currentMathValues, lastState.mathValues);
                    updateAllInputs();
                    updateComputations();
                    updateVisualizations();
                    showTemporaryMessage('State loaded successfully!');
                }
            }
        }

        function updateAllInputs() {
            Object.keys(interactiveElements).forEach(key => {
                const input = document.getElementById(`edit-${key}`) || document.getElementById(key);
                const slider = document.getElementById(`slider-${key}`);
                const value = interactiveElements[key].value;
                
                if (input) input.value = value;
                if (slider) slider.value = value;
            });
        }

        function updateInteractionHints() {
            const hints = {
                'explore': 'Click to interact • Drag to adjust • Right-click for options',
                'edit': 'Direct editing mode • Type new values • Scrub to adjust',
                'debug': 'Debug mode • Inspect computations • Trace data flow',
                'tutorial': 'Tutorial mode • Follow guided steps • Learn interactively'
            };
            document.getElementById('interaction-hint').textContent = hints[currentInteractionMode] || '';
        }

        // Context menu actions
        function inspectElement() {
            if (lastRightClickTarget) {
                const elementInfo = getElementInfo(lastRightClickTarget);
                showExplanationDialog('Element Inspector', elementInfo);
            }
        }

        function editElement() {
            if (lastRightClickTarget && lastRightClickTarget.dataset.value) {
                const key = lastRightClickTarget.dataset.value;
                const current = interactiveElements[key].value;
                const newValue = prompt(`Edit ${key}:`, current);
                if (newValue !== null && !isNaN(newValue)) {
                    interactiveElements[key].value = parseFloat(newValue);
                    updateComputations();
                    updateVisualizations();
                }
            }
        }

        function resetElement() {
            if (lastRightClickTarget && lastRightClickTarget.dataset.value) {
                const key = lastRightClickTarget.dataset.value;
                const defaults = { x1: 0.5, x2: 0.3, target: 0.8, w11: 0.1, w12: 0.2, w21: 0.3, w22: 0.4, bias: 0.1, lr: 0.01, momentum: 0.9 };
                interactiveElements[key].value = defaults[key] || 0;
                updateComputations();
                updateVisualizations();
            }
        }

        function explainElement() {
            if (lastRightClickTarget) {
                const explanation = getElementExplanation(lastRightClickTarget);
                showExplanationDialog('Element Explanation', explanation);
            }
        }

        function copyElement() {
            if (lastRightClickTarget) {
                const value = getElementValue(lastRightClickTarget);
                navigator.clipboard.writeText(value);
                showTemporaryMessage('Element value copied!');
            }
        }

        function getElementInfo(element) {
            return `Element: ${element.tagName}\nClasses: ${element.className}\nDataset: ${JSON.stringify(element.dataset)}\nText: ${element.textContent}`;
        }

        function getElementExplanation(element) {
            const info = element.dataset.info;
            return tooltipInfo[info] || 'No explanation available for this element.';
        }

        function getElementValue(element) {
            return element.textContent || element.value || 'No value';
        }

        // Canvas interaction handlers
        function handleCanvasClick(x, y) {
            // Handle clicks on canvas elements based on current visualization step
            console.log(`Canvas clicked at (${x}, ${y}) in step ${mathStep}`);
        }

        function updateCanvasCursor(x, y) {
            // Update cursor based on hoverable canvas elements
            mathCanvas.style.cursor = 'default';
        }

        function highlightConnectedElements(nodeId) {
            // Highlight elements connected to the selected node
            console.log(`Highlighting elements connected to ${nodeId}`);
        }

        // Add CSS animation for fadeInOut
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeInOut {
                0% { opacity: 0; transform: translateX(100%); }
                20% { opacity: 1; transform: translateX(0); }
                80% { opacity: 1; transform: translateX(0); }
                100% { opacity: 0; transform: translateX(100%); }
            }
        `;
        document.head.appendChild(style);

        // Initialize the ultra-interactive system when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(initializeUltraInteractiveSystem, 1500);
        });
    </script>
</body>
</html> 